<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHANNEL App (GitHub Pages)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://unpkg.com/@daily-co/daily-js"></script>

    <link rel="manifest" href="/channel/manifest.json">
    <link rel="apple-touch-icon" href="/channel/icons/icon-192x192.png">
    <meta name="theme-color" content="#2563eb">

    <script type="module">
        // Importa módulos de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Importa addDoc, getDocs, deleteDoc y serverTimestamp para añadir mensajes y marcas de tiempo
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, addDoc, serverTimestamp, orderBy, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // Variables globales para la configuración de Firebase.
        // IMPORTANTE: En un entorno Canvas real, estas se proporcionan automáticamente.
        // Para pruebas locales, tus detalles de configuración de Firebase reales ahora están incluidos a continuación.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Reemplaza 'default-app-id' si Canvas proporciona uno
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify({
            apiKey: "AIzaSyBELawPeUmP2tRaL19X7Tr6MRcI9oMgdSM", // Tu clave API de Firebase
            authDomain: "channel-jl.firebaseapp.com", // Tu dominio de autenticación de Firebase
            projectId: "channel-jl", // Tu ID de proyecto de Firebase
            storageBucket: "channel-jl.firebasestorage.app", // Tu Firebase Storage Bucket
            messagingSenderId: "350780625607", // Tu ID de aplicación de Firebase
            appId: "1:350780625607:web:a0275d6d6ee89b0813a4e2" // Tu ID de aplicación de Firebase
        });
        window.__initial_auth_token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : ''; // Deja vacío para inicio de sesión anónimo

        // Inicializa los servicios de Firebase globalmente
        window.firebaseApp = initializeApp(JSON.parse(window.__firebase_config));
        console.log("DEBUG PROFUNDO: window.firebaseApp:", window.firebaseApp); // Registra el objeto completo de la app
        window.db = getFirestore(window.firebaseApp);
        window.auth = getAuth(window.firebaseApp);

        // Expone las funciones de Firebase Firestore globalmente para que el componente React las use
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        // Expone nuevas funciones de Firestore
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.orderBy = orderBy;
        window.getDocs = getDocs; // Expone getDocs para la eliminación de subcolecciones
        window.deleteDoc = deleteDoc; // Expone deleteDoc para la eliminación de canales
        // NUEVO: Exponer signInAnonymously globalmente
        window.signInAnonymously = signInAnonymously;


        // PWA: Registra el Service Worker con la ruta corregida para tu repositorio 'channel'
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/channel/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Fallo el registro del Service Worker: ', registrationError);
                    });
            });
        }
    </script>
    <style>
        /* Estilo básico para el cuerpo para aplicar la fuente Inter */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* El iframe de Daily.co llenará su contenedor padre */
        #daily-video-container iframe {
            width: 100%;
            height: 100%;
            border: none; /* Elimina el borde predeterminado del iframe */
        }

        /* Estilos del spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Estilo añadido para el botón de retroceso para asegurar que sea clickeable */
        .back-button-z-index {
            z-index: 60 !important; /* Más alto que el z-index del spinner (50) */
            position: relative; /* Asegura que se aplique el z-index */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Función de ayuda para generar un nombre de usuario aleatorio para nuevos usuarios
        const generateRandomUserName = () => {
            const adjectives = ['Veloz', 'Sabio', 'Curioso', 'Audaz', 'Brillante', 'Silencioso', 'Fuerte', 'Gentil', 'Salvaje', 'Lujurioso', 'Hambriento', 'Envidioso', 'Furioso', 'Chad', 'Grande', 'Venoso', 'Oscuro', 'Chiquito'];
            const nouns = ['Lobo', 'Zorro', 'Águila', 'Tigre', 'Oso', 'Panda', 'Delfín', 'León', 'Perro', 'Gato', 'Puma', 'Pichón', 'Gorrión', 'Caballo', 'Gorila', 'Pinguino', 'Hombre', 'Mono', 'Ratón'];
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNumber = Math.floor(Math.random() * 1000);
            return `${randomAdjective}${randomNoun}${randomNumber}`;
        };

        // Componente de mensaje para mostrar retroalimentación al usuario (reemplaza alert())
        const MessageDisplay = ({ message, type, onClose }) => {
            if (!message) return null;

            const bgColor = type === 'error' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-green-100 border-green-400 text-green-700';
            const borderColor = type === 'error' ? 'border-red-500' : 'border-green-500';

            return (
                <div className={`fixed top-4 right-4 p-4 rounded-lg shadow-lg flex items-center justify-between z-50 ${bgColor} border ${borderColor}`}>
                    <p className="font-semibold">{message}</p>
                    <button onClick={onClose} className="ml-4 text-lg font-bold">
                        &times;
                    </button>
                </div>
            );
        };

        // Componente de spinner de carga
        const LoadingSpinner = () => (
            // Este div sigue siendo el overlay de pantalla completa (sin fondo propio)
            <div className="fixed inset-0 flex items-center justify-center z-50">
                {/* Este nuevo div es el contenedor para el spinner y el texto, y tendrá el fondo semitransparente */}
                <div style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)', padding: '20px', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <div className="spinner"></div>
                    <p className="ml-4 text-white text-lg">Cargando...</p>
                </div>
            </div>
        );
        // Componente principal de la aplicación
        const App = () => {
            // Estado para gestionar la vista actual: 'home', 'channel' o 'explore'
            const [currentPage, setCurrentPage] = React.useState('home');
            // Estado para almacenar el nombre del canal introducido por el usuario
            const [channelName, setChannelName] = React.useState('');
            // Estado para almacenar el nombre del canal activo al ver un canal
            const [activeChannel, setActiveChannel] = React.useState('');
            // Estado para almacenar una lista de canales disponibles para la página de exploración
            const [availableChannels, setAvailableChannels] = React.useState([]);
            // Estado para almacenar el nombre de visualización elegido por el usuario
            const [userName, setUserName] = React.useState('');
            // Estado para rastrear si el nombre de usuario ha sido confirmado
            const [userNameConfirmed, setUserNameConfirmed] = React.useState(false);
            // Estado para mostrar mensajes al usuario
            const [message, setMessage] = React.useState(null);
            const [messageType, setMessageType] = React.useState('');

            // NUEVO: Estado para el mensaje actual que se está escribiendo
            const [currentMessage, setCurrentMessage] = React.useState('');
            // NUEVO: Estado para los mensajes de chat
            const [chatMessages, setChatMessages] = React.useState([]);

            // Firebase related states
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [userId, setUserId] = React.useState(null);
            const [isAuthReady, setIsAuthReady] = React.useState(false);
            // NUEVO: Estado para el estado de carga general
            const [isLoading, setIsLoading] = React.useState(true);

            // Estado para la visibilidad del menú de opciones (para la página de canal)
            const [showOptionsMenu, setShowOptionsMenu] = React.useState(false);
            // NUEVO: Estado para la visibilidad del panel de actividad (lista de usuarios)
            const [showActivityPanel, setShowActivityPanel] = React.useState(false);
            // NUEVO: Estado para almacenar los miembros del canal (histórico)
            const [channelMembers, setChannelMembers] = React.useState([]);
            // NUEVO: Estado para almacenar los participantes actualmente online en la llamada Daily.co
            const [onlineParticipants, setOnlineParticipants] = React.useState(new Set());


            // Estados de Daily.co
            const [dailyCallFrame, setDailyCallFrame] = React.useState(null); // El objeto del marco de llamada de Daily.co
            const [isStreaming, setIsStreaming] = React.useState(false); // Indica si Daily.co está activo
            const [dailyError, setDailyError] = React.useState(null); // Para errores específicos de Daily.co

            // PWA: Estado para el evento beforeinstallprompt
            const [deferredPrompt, setDeferredPrompt] = React.useState(null);
            // PWA: Estado para saber si la PWA ya está instalada
            const [isPwaInstalled, setIsPwaInstalled] = React.useState(false);

            // NUEVO: Estados para el modo Tigre
            const [showTigreCodeInput, setShowTigreCodeInput] = React.useState(false); // Controla la visibilidad del input de código
            const [tigreCode, setTigreCode] = React.useState(''); // Almacena el código ingresado
            const [isTigre, setIsTigre] = React.useState(false); // Indica si el modo Tigre está activo


            // Ref para el campo de entrada del nombre del canal
            const channelInputRef = React.useRef(null);
            // NUEVO: Ref para el div de mensajes de chat para habilitar el desplazamiento automático
            const chatMessagesEndRef = React.useRef(null);
            // Ref para el botón del menú de opciones para manejar clics externos (para la página de canal)
            const optionsMenuRef = React.useRef(null);
            // NUEVO: Ref para el menú de opciones de la página de exploración
            const exploreMenuRef = React.useRef(null);
            // NUEVO: Ref para la entrada de archivo oculta
            const fileInputRef = React.useRef(null);

            // NUEVO: Estado para la opción de ordenamiento en la página de exploración
            // 'activity' (mayor actividad/más reciente), 'recent' (más recientes por creación)
            const [sortOption, setSortOption] = React.useState('activity');
            // NUEVO: Estado para controlar la visibilidad del menú de exploración
            const [showExploreMenu, setShowExploreMenu] = React.useState(false);
            // NUEVO: Estado para la consulta de búsqueda en la página de exploración
            const [searchQuery, setSearchQuery] = React.useState('');
            // NUEVO: Estado para controlar la visibilidad del campo de búsqueda
            const [showSearchInput, setShowSearchInput] = React.useState(false);
            // NUEVO: Ref para el input de búsqueda
            const searchInputRef = React.useRef(null);


            // Función para mostrar un mensaje
            const showMessage = React.useCallback((msg, type = 'success') => {
                setMessage(msg);
                setMessageType(type);
                setTimeout(() => setMessage(null), 3000); // Borra el mensaje después de 3 segundos
            }, []);

            // NUEVO: Función para desplazarse al final de los mensajes de chat
            const scrollToBottom = React.useCallback(() => {
                chatMessagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, []);

            // PWA: Maneja el evento beforeinstallprompt
            React.useEffect(() => {
                const handler = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    console.log('beforeinstallprompt event fired!');
                };
                window.addEventListener('beforeinstallprompt', handler);

                if (window.matchMedia('(display-mode: standalone)').matches) {
                    setIsPwaInstalled(true);
                }

                return () => window.removeEventListener('beforeinstallprompt', handler);
            }, []);

            // PWA: Maneja el evento appinstalled (cuando el usuario instala la PWA)
            React.useEffect(() => {
                const handleAppInstalled = () => {
                    setIsPwaInstalled(true);
                    setDeferredPrompt(null);
                    showMessage('Instalando CHANNEL App...', 'success');
                    console.log('PWA was installed');
                };
                window.addEventListener('appinstalled', handleAppInstalled);
                return () => window.removeEventListener('appinstalled', handleAppInstalled);
            }, [showMessage]);

            // 1. Initial Firebase setup and user authentication, and profile loading
            React.useEffect(() => {
                setDb(window.db);
                setAuth(window.auth);

                const unsubscribeAuth = window.onAuthStateChanged(window.auth, async (user) => {
                    let currentUserId = null;
                    if (user) {
                        currentUserId = user.uid;
                        setUserId(currentUserId);
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - userId establecido:", currentUserId);
                    } else {
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - Usuario no autenticado, intentando signInAnonymously si es necesario.");
                        try {
                            const userCredential = await window.signInAnonymously(window.auth);
                            currentUserId = userCredential.user.uid;
                            setUserId(currentUserId);
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - userId ANÓNIMO establecido después de signIn:", currentUserId);
                        } catch (anonError) {
                            console.error("DEBUG PROFUNDO: Error durante el inicio de sesión anónimo en onAuthStateChanged:", anonError);
                            // Fallback to a client-side generated ID if anonymous sign-in fails
                            currentUserId = (Math.random().toString(36).substring(2) + Date.now().toString(36));
                            setUserId(currentUserId);
                            showMessage("No se pudo autenticar al usuario. Usando ID de respaldo. Algunas funciones podrían estar limitadas.", 'error');
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - userId de respaldo establecido debido a error de inicio de sesión:", currentUserId);
                        }
                    }

                    // *** MODIFICACIÓN CLAVE AQUÍ: Asegurarse de que db y userId estén disponibles antes de interactuar con Firestore ***
                    if (currentUserId && window.db) {
                        const userProfileRef = window.doc(window.db, `artifacts/${window.__app_id}/users/${currentUserId}/profile`, 'userProfile');
                        try {
                            console.log("DEBUG PROFUNDO: Intentando leer/crear perfil de usuario en la ruta:", userProfileRef.path);
                            const userProfileSnap = await window.getDoc(userProfileRef);

                            let profileData;
                            if (userProfileSnap.exists()) {
                                profileData = userProfileSnap.data();
                                console.log(`DEBUG PROFUNDO: Perfil de usuario cargado para ${currentUserId}.`);
                            } else {
                                // If profile doesn't exist, create it with a new random one
                                const userNameToUse = generateRandomUserName();
                                profileData = {
                                    userName: userNameToUse,
                                    isTigreActive: false
                                };
                                await window.setDoc(userProfileRef, profileData);
                                // No need to set localStorage here, userName state will be set below
                                console.log(`DEBUG PROFUNDO: Perfil de usuario creado para ${currentUserId}.`);
                            }

                            // Update React states based on the loaded/created profile data
                            setUserName(profileData.userName);
                            setUserNameConfirmed(true); // User name is confirmed if profile exists
                            setIsTigre(profileData.isTigreActive === true); // Ensure boolean true

                            // IMPORTANT: showTigreCodeInput is NOT set here anymore.
                            // It will be triggered by handleConfirmUserName if userName is 'Julian360'.

                        } catch (profileError) {
                            console.error("DEBUG PROFUNDO: Error al cargar/crear el perfil de usuario desde Firestore (dentro de onAuthStateChanged):", profileError);
                            setIsTigre(false);
                            setShowTigreCodeInput(false); // Ensure this is false on error
                            showMessage("Error al cargar tu perfil de usuario. Consulta la consola.", 'error');
                        }
                    } else {
                        // Fallback if currentUserId or db is not available, ensure Tigre mode is off
                        setIsTigre(false);
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: No hay userId o db disponible para cargar el perfil. isTigre establecido a false.");
                    }
                    setIsAuthReady(true);
                    setIsLoading(false);
                    console.log("DEBUG PROFUNDO: isAuthReady establecido a true.");
                });

                return () => unsubscribeAuth();
            }, [showMessage]); // Add showMessage to dependency array


            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state && event.state.page) {
                        setCurrentPage(event.state.page);
                        if (event.state.page === 'home' || event.state.page === 'explore') {
                            if (dailyCallFrame) {
                                dailyCallFrame.leave();
                                setDailyCallFrame(null);
                                setIsStreaming(false);
                            }
                        }
                    } else {
                        setCurrentPage('home');
                        if (dailyCallFrame) {
                            dailyCallFrame.leave();
                            setDailyCallFrame(null);
                            setIsStreaming(false);
                        }
                    }
                };

                window.addEventListener('popstate', handlePopState);
                window.history.pushState({ page: currentPage }, document.title, null);
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [currentPage, dailyCallFrame]);

            React.useEffect(() => {
                if (currentPage && (!window.history.state || window.history.state.page !== currentPage)) {
                    window.history.pushState({ page: currentPage }, document.title, null);
                }
            }, [currentPage]);

            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (optionsMenuRef.current && !optionsMenuRef.current.contains(event.target)) {
                        setShowOptionsMenu(false);
                        setShowActivityPanel(false);
                    }
                    if (exploreMenuRef.current && !exploreMenuRef.current.contains(event.target)) {
                        setShowExploreMenu(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [optionsMenuRef, exploreMenuRef]);

            const fetchChannels = React.useCallback(async () => {
                if (!isAuthReady || !db) {
                    console.log("DEBUG PROFUNDO: fetchChannels - Firebase no listo o db es null. Saliendo.");
                    return;
                }
                setIsLoading(true);
                const channelsColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels`);
                const q = window.query(channelsColRef);

                try {
                    const snapshot = await window.getDocs(q);
                    const channelsData = snapshot.docs.map(doc => ({
                        id: doc.id,
                        name: doc.data().displayName || doc.id,
                        createdAt: doc.data().createdAt,
                        createdBy: doc.data().createdBy,
                        creatorUserName: doc.data().creatorUserName,
                        dailyCoRoomUrl: doc.data().dailyCoRoomUrl,
                        lastActivity: doc.data().lastActivity
                    }));

                    let processedChannels = [...channelsData];

                    if (sortOption === 'activity') {
                        processedChannels.sort((a, b) => {
                            const dateA = a.lastActivity ? a.lastActivity.toDate() : new Date(a.createdAt);
                            const dateB = b.lastActivity ? b.lastActivity.toDate() : new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    } else if (sortOption === 'recent') {
                        processedChannels.sort((a, b) => {
                            const dateA = new Date(a.createdAt);
                            const dateB = new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    }

                    if (searchQuery) {
                        processedChannels = processedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(searchQuery.toLowerCase())
                        );
                    }

                    setAvailableChannels(processedChannels);
                    console.log("DEBUG PROFUNDO: Canales obtenidos y procesados:", processedChannels);
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error al obtener canales:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Error de conexión o permisos. Asegúrate de que tus reglas de Firestore sean correctas y tengas conexión a internet.", 'error');
                    } else {
                        showMessage("Error al cargar canales. Consulta la consola.", 'error');
                    }
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, sortOption, searchQuery, showMessage, setIsLoading, setAvailableChannels]);


            React.useEffect(() => {
                let intervalId;
                if (currentPage === 'explore') {
                    fetchChannels();
                    intervalId = setInterval(fetchChannels, 60000);
                }

                return () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                };
            }, [currentPage, fetchChannels]);


            React.useEffect(() => {
                if (showSearchInput && searchInputRef.current) {
                    searchInputRef.current.focus();
                }
            }, [showSearchInput]);


            React.useEffect(() => {
                if (isAuthReady && db && activeChannel && currentPage === 'channel') {
                    const normalizedActiveChannel = activeChannel.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    const q = window.query(messagesColRef, window.orderBy('timestamp'));

                    const unsubscribe = window.onSnapshot(q, (snapshot) => {
                        const messagesData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChatMessages(messagesData);
                        scrollToBottom();
                        console.log("DEBUG PROFUNDO: Mensajes de chat actualizados:", messagesData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error al obtener mensajes de chat:", error);
                        if (error.code === 'unavailable' || error.code === 'permission-denied') {
                            showMessage("Error de conexión o permisos al cargar mensajes. Verifica las reglas de Firestore.", 'error');
                        } else {
                            showMessage("Error al cargar mensajes del chat. Consulta la consola.", 'error');
                        }
                    });

                    const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/members`);
                    const unsubscribeMembers = window.onSnapshot(membersColRef, (snapshot) => {
                        const membersData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChannelMembers(membersData);
                        console.log("DEBUG PROFUNDO: Miembros del canal actualizados:", membersData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error al obtener miembros del canal:", error);
                    });


                    return () => {
                        unsubscribe();
                        unsubscribeMembers();
                    };
                } else {
                    setChatMessages([]);
                    setChannelMembers([]);
                    console.log("DEBUG PROFUNDO: Limpiando mensajes y miembros del canal.");
                }
            }, [isAuthReady, db, activeChannel, currentPage, showMessage, scrollToBottom]);

            const handleConfirmUserName = React.useCallback(async () => {
                if (userName.trim() === '') {
                    showMessage('Por favor, ingresa un nombre de usuario.', 'error');
                    return;
                }
                if (userName.trim().length > 48) {
                    showMessage('El nombre de usuario no puede exceder los 48 caracteres.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleConfirmUserName - Firebase no está listo o db/userId es null.");
                    showMessage("La autenticación no está lista. Inténtalo de nuevo.", 'error');
                    return;
                }
                setIsLoading(true);
                try {
                    const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                    let profileUpdate = { userName: userName.trim() };

                    // Only set isTigreActive to false here, it will be set to true by handleTigreCodeSubmit
                    profileUpdate.isTigreActive = false;

                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Guardando perfil de usuario:", { userId: userId, userName: userName.trim(), isTigreActive: profileUpdate.isTigreActive });
                    await window.setDoc(userProfileRef, profileUpdate, { merge: true });
                    // No need to set localStorage here, userName state is already updated
                    setUserNameConfirmed(true);
                    showMessage('¡Nombre de usuario confirmado!', 'success');
                    setIsTigre(profileUpdate.isTigreActive); // This will be false here

                    // NEW LOGIC: Only show Tigre code input IF userName is Julian360 AND isTigre is NOT active
                    if (userName.trim() === 'Julian360' && !profileUpdate.isTigreActive) {
                        setShowTigreCodeInput(true);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - Usuario es Julian360 y modo Tigre inactivo. Mostrando input de código Tigre.");
                    } else {
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - Usuario NO es Julian360 o modo Tigre activo. Ocultando input de código Tigre.");
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error al guardar el nombre de usuario:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Error de conexión o permisos. Asegúrate de que tus reglas de Firestore sean correctas y tengas conexión a internet.", 'error');
                    } else {
                        showMessage("Error al guardar el nombre de usuario. Inténtalo de nuevo.", 'error');
                    }
                } finally {
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage, setIsLoading, setShowTigreCodeInput, setIsTigre, setUserNameConfirmed]);

            const handleTigreCodeSubmit = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - userId actual:", userId);
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Código ingresado:", tigreCode);
                if (parseInt(tigreCode) === (15476 * 1000 + 767)) {
                    setIsTigre(true);
                    showMessage('Modo Tigre activado. Ahora puedes eliminar cualquier canal.', 'success');
                    setShowTigreCodeInput(false);

                    if (db && userId) {
                        try {
                            const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Intentando activar modo Tigre en Firestore para userId:", userId, "con isTigreActive: true (booleano).");
                            await window.setDoc(userProfileRef, { isTigreActive: true }, { merge: true });
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Modo Tigre activado en Firestore para el usuario:", userId);
                            const updatedProfileSnap = await window.getDoc(userProfileRef);
                            if (updatedProfileSnap.exists()) {
                                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Perfil de usuario LEÍDO después de la actualización:", updatedProfileSnap.data());
                            }
                        } catch (error) {
                            console.error("DEBUG PROFUNDO: handleTigreCodeSubmit - Error al activar el modo Tigre en Firestore:", error);
                            showMessage("Error al guardar el estado de Tigre. Inténtalo de nuevo.", 'error');
                        }
                    }

                } else {
                    showMessage('Código incorrecto. Inténtalo de nuevo.', 'error');
                    setTigreCode('');
                    console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Código incorrecto.");
                }
            }, [tigreCode, showMessage, setIsTigre, setShowTigreCodeInput, setTigreCode, db, userId]);

            const handleCreateChannel = React.useCallback(async () => {
                if (channelName.trim() === '') {
                    showMessage('Por favor, ingresa un nombre para el canal.', 'error');
                    if (channelInputRef.current) {
                        channelInputRef.current.focus();
                    }
                    return;
                }
                if (channelName.trim().length > 128) {
                    showMessage('El nombre del canal no puede exceder los 128 caracteres.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleCreateChannel - Firebase no está listo aún. Por favor, espera.");
                    showMessage("La autenticación no está lista. Inténtalo de nuevo.", 'error');
                    return;
                }

                const normalizedChannelName = channelName.trim().toLowerCase();
                const originalChannelInput = channelName.trim();

                setIsLoading(true);
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                    const docSnap = await window.getDoc(channelDocRef);

                    const dailyCoRoomUrl = `https://YOUR_DAILY_DOMAIN.daily.co/${normalizedChannelName}-video`; // Asegúrate de reemplazar YOUR_DAILY_DOMAIN

                    if (docSnap.exists()) {
                        const existingChannelDisplayName = docSnap.data().displayName || normalizedChannelName;
                        setActiveChannel(existingChannelDisplayName);
                        setCurrentPage('channel');
                        showMessage(`Te has unido al canal: ${existingChannelDisplayName}`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Canal existente unido:", existingChannelDisplayName);
                    } else {
                        await window.setDoc(channelDocRef, {
                            name: normalizedChannelName,
                            displayName: originalChannelInput,
                            createdAt: new Date().toISOString(),
                            createdBy: userId,
                            creatorUserName: userName,
                            dailyCoRoomUrl: dailyCoRoomUrl,
                            lastActivity: window.serverTimestamp()
                        });
                        setActiveChannel(originalChannelInput);
                        setCurrentPage('channel');
                        showMessage(`¡Canal "${originalChannelInput}" creado y te has unido!`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Canal creado y unido:", originalChannelInput);
                    }

                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    await window.setDoc(memberDocRef, {
                        userName: userName,
                        joinedAt: window.serverTimestamp()
                    }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Miembro añadido al canal:", userId);

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error al crear o unirse al canal:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Error de conexión o permisos. Asegúrate de que tus reglas de Firestore sean correctas y tengas conexión a internet.", 'error');
                    } else {
                        showMessage("Error al crear o unirse al canal. Consulta la consola.", 'error');
                    }
                } finally {
                    setIsLoading(false);
                }
            }, [channelName, userName, isAuthReady, db, userId, showMessage, setIsLoading, setCurrentPage, setActiveChannel]);

            const handleJoinChannelFromExplore = React.useCallback(async (channelToJoin) => {
                setActiveChannel(channelToJoin.name);
                setCurrentPage('channel');
                if (dailyCallFrame) {
                    dailyCallFrame.leave();
                    setDailyCallFrame(null);
                    setIsStreaming(false);
                }
                showMessage(`Te has unido al canal: ${channelToJoin.name}`, 'success');
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Unido al canal:", channelToJoin.name);

                if (isAuthReady && db && userId && userName) {
                    const normalizedChannelName = channelToJoin.name.toLowerCase();
                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    try {
                        console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Añadiendo miembro al unirse al canal:", userId);
                        await window.setDoc(memberDocRef, {
                            userName: userName,
                            joinedAt: window.serverTimestamp()
                        }, { merge: true });
                    } catch (error) {
                        console.error("DEBUG PROFUNDO: Error al añadir miembro al unirse al canal:", error);
                    }
                }
            }, [userName, isAuthReady, db, userId, showMessage, setCurrentPage, setActiveChannel, dailyCallFrame]);

            const handleSendMessage = React.useCallback(async () => {
                if (currentMessage.trim() === '') {
                    return;
                }
                if (!isAuthReady || !db || !userId || !activeChannel || !userName) {
                    console.warn("DEBUG PROFUNDO: handleSendMessage - Firebase, usuario, canal o nombre de usuario no están listos. No se puede enviar el mensaje.");
                    showMessage("No se pudo enviar el mensaje. La aplicación no está lista.", 'error');
                    return;
                }

                const normalizedActiveChannel = activeChannel.toLowerCase();

                try {
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    console.log("DEBUG PROFUNDO: handleSendMessage - Enviando mensaje:", currentMessage.trim(), "a canal:", normalizedActiveChannel);
                    await window.addDoc(messagesColRef, {
                        text: currentMessage.trim(),
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                    });
                    setCurrentMessage('');
                    scrollToBottom();

                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { lastActivity: window.serverTimestamp() }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleSendMessage - Última actividad del canal actualizada.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error al enviar mensaje:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Error de conexión o permisos al enviar mensaje. Verifica las reglas de Firestore.", 'error');
                    } else {
                        showMessage("Error al enviar mensaje. Consulta la consola.", 'error');
                    }
                }
            }, [currentMessage, userName, activeChannel, isAuthReady, db, userId, showMessage, scrollToBottom]);

            const handleDeleteChannel = React.useCallback(async (channelDisplayName) => {
                console.log("DEBUG PROFUNDO: handleDeleteChannel - userId actual:", userId);
                console.log("DEBUG PROFUNDO: handleDeleteChannel - Iniciando eliminación para canal:", channelDisplayName);
                const userConfirmed = await new Promise((resolve) => {
                    const confirmModal = document.createElement('div');
                    confirmModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    confirmModal.innerHTML = `
                        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
                            <p class="mb-4 text-lg">¿Estás seguro de que quieres eliminar el canal "${channelDisplayName}"? Esta acción es irreversible.</p>
                            <button id="confirmDelete" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Sí, Eliminar</button>
                            <button id="cancelDelete" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancelar</button>
                        </div>
                    `;
                    document.body.appendChild(confirmModal);

                    document.getElementById('confirmDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(true);
                    };
                    document.getElementById('cancelDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(false);
                    };
                });

                if (!userConfirmed) {
                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Eliminación cancelada por el usuario.");
                    return;
                }

                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleDeleteChannel - Firebase no está listo o db/userId es null. No se puede eliminar.");
                    showMessage("Firebase no está listo o no tienes un ID de usuario. No se puede eliminar el canal.", 'error');
                    return;
                }

                const normalizedChannelId = channelDisplayName.toLowerCase();

                setIsLoading(true);
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelId);
                    const docSnap = await window.getDoc(channelDocRef);

                    if (!docSnap.exists()) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Canal no existe.");
                        showMessage("El canal no existe.", 'error');
                        setIsLoading(false);
                        return;
                    }

                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Valores para la evaluación de permisos:");
                    console.log("DEBUG PROFUNDO:   - userId (actual):", userId);
                    console.log("DEBUG PROFUNDO:   - isTigre (estado React):", isTigre);
                    console.log("DEBUG PROFUNDO:   - channel.createdBy (desde Firestore):", docSnap.data().createdBy);
                    console.log("DEBUG PROFUNDO:   - ¿userId === channel.createdBy?:", userId === docSnap.data().createdBy);

                    if (isTigre || docSnap.data().createdBy === userId) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permiso CONCEDIDO. Iniciando eliminación de subcolecciones y canal.");

                        const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`);
                        const messagesSnapshot = await window.getDocs(messagesColRef);
                        const deleteMessagePromises = [];
                        messagesSnapshot.forEach(msgDoc => {
                            deleteMessagePromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`, msgDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Eliminando ${deleteMessagePromises.length} mensajes.`);
                        await Promise.all(deleteMessagePromises);

                        const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`);
                        const membersSnapshot = await window.getDocs(membersColRef);
                        const deleteMemberPromises = [];
                        membersSnapshot.forEach(memberDoc => {
                            deleteMemberPromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`, memberDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Eliminando ${deleteMemberPromises.length} miembros.`);
                        await Promise.all(deleteMemberPromises);


                        await window.deleteDoc(channelDocRef);
                        showMessage(`Canal "${channelDisplayName}" eliminado con éxito.`, 'success');
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Canal principal eliminado.");
                        fetchChannels();
                    } else {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permiso DENEGADO. Condiciones no cumplidas.");
                        showMessage("No tienes permiso para eliminar este canal.", 'error');
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error al eliminar el canal (catch general):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Error de conexión o permisos. Asegúrate de que tus reglas de Firestore sean correctas y tengas conexión a internet.", 'error');
                        } else {
                        showMessage("Error al eliminar el canal. Consulta la consola.", 'error');
                    }
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, userId, isTigre, showMessage, setIsLoading, fetchChannels]);


            const handleToggleCamera = React.useCallback(async () => {
                if (!activeChannel || !userId) {
                    showMessage("No hay un canal activo o el usuario no está autenticado.", 'error');
                    return;
                }

                if (dailyCallFrame && isStreaming) {
                    dailyCallFrame.leave();
                    showMessage("Cámara apagada.", 'info');
                } else {
                    setIsStreaming(true);
                    setDailyError(null);
                    setIsLoading(true);

                    try {
                        const normalizedChannelName = activeChannel.toLowerCase();
                        const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                        const docSnap = await window.getDoc(channelDocRef);

                        if (!docSnap.exists() || !docSnap.data().dailyCoRoomUrl) {
                            showMessage("No se encontró URL de Daily.co para este canal. Asegúrate de crearla primero (editando la URL de Daily.co en el código).", 'error');
                            setIsStreaming(false);
                            setIsLoading(false);
                            return;
                        }

                        const dailyCoRoomUrl = `https://YOUR_DAILY_DOMAIN.daily.co/${normalizedChannelName}-video`; // Asegúrate de reemplazar YOUR_DAILY_DOMAIN
                        const videoContainerElement = document.getElementById('daily-video-container');

                        if (!videoContainerElement) {
                            showMessage("Error: No se encontró el contenedor de video Daily.co. Verifica el HTML.", 'error');
                            setIsStreaming(false);
                            setIsLoading(false);
                            return;
                        }

                        const call = window.DailyIframe.createFrame({
                            parent: videoContainerElement,
                            showLeaveButton: true,
                            showParticipantsBar: false,
                            iframeStyle: {
                                position: 'relative',
                                width: '100%',
                                height: '100%',
                                border: '0',
                            },
                        });

                        setDailyCallFrame(call);

                        await call.join({ url: dailyCoRoomUrl, userName: userName || userId });
                        showMessage("Cámara encendida. ¡Estás transmitiendo!", 'success');


                        call.on('joined-meeting', () => {
                            console.log('Daily.co: Joined meeting');
                            if (videoContainerElement) {
                                videoContainerElement.classList.remove('hidden');
                            }
                            setIsLoading(false);

                            const participants = call.participants();
                            const currentOnline = new Set();
                            for (const id in participants) {
                                currentOnline.add(id);
                            }
                            setOnlineParticipants(currentOnline);
                        });

                        call.on('participant-joined', (e) => {
                            console.log('Daily.co: Participant joined', e.participant.user_id);
                            setOnlineParticipants(prev => new Set(prev).add(e.participant.user_id));
                        });

                        call.on('participant-left', (e) => {
                            console.log('Daily.co: Participant left', e.participant.user_id);
                            setOnlineParticipants(prev => {
                                const newSet = new Set(prev);
                                newSet.delete(e.participant.user_id);
                                return newSet;
                            });
                        });


                        call.on('left-meeting', () => {
                            console.log('Daily.co: Left meeting');
                            setIsStreaming(false);
                            setDailyCallFrame(null);
                            setOnlineParticipants(new Set());
                            showMessage("La transmisión ha terminado.", 'info');
                            if (videoContainerElement) {
                                videoContainerElement.classList.add('hidden');
                            }
                            if (call.iframe && call.iframe.parentNode) {
                                call.iframe.parentNode.removeChild(call.iframe);
                            }
                        });

                        call.on('error', (e) => {
                            console.error('Daily.co Error:', e);
                            setDailyError(e);
                            showMessage(`Error de video: ${e.message}`, 'error');
                            setIsStreaming(false);
                            setOnlineParticipants(new Set());
                            if (call.iframe && call.iframe.parentNode) {
                                call.iframe.parentNode.removeChild(call.iframe);
                            }
                            if (videoContainerElement) {
                                videoContainerElement.classList.add('hidden');
                            }
                            setIsLoading(false);
                        });

                    } catch (error) {
                        console.error("Error al iniciar la cámara con Daily.co:", error);
                        setDailyError(error);
                        setIsStreaming(false);
                        showMessage(`Error al iniciar la cámara: ${error.message}`, 'error');
                        setIsLoading(false);
                    }
                }
            }, [activeChannel, userId, dailyCallFrame, isStreaming, showMessage, setIsLoading, setDailyError, userName, db]);

            React.useEffect(() => {
                return () => {
                    if (dailyCallFrame) {
                        dailyCallFrame.leave();
                    }
                };
            }, [dailyCallFrame]);

            const copyToClipboard = React.useCallback((text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showMessage(`"${text}" copiado al portapapeles!`, 'success');
                } catch (err) {
                    console.error('Error al copiar al portapapeles:', err);
                    showMessage('Error al copiar al portapapeles.', 'error');
                }
                document.body.removeChild(textarea);
            }, [showMessage]);

            const handleAttachFile = React.useCallback(() => {
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
                setShowOptionsMenu(false);
            }, []);


            const onFileSelected = React.useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                if (!isAuthReady || !db || !userId || !activeChannel) {
                    showMessage("La aplicación no está lista para subir archivos. Inténtalo de nuevo.", 'error');
                    return;
                }

                setIsLoading(true);

                // --- Configuración de Cloudinary (REEMPLAZA ESTOS CON LOS TUYOS) ---
                const cloudName = 'dq527zvti'; // Tu nombre de Cloudinary Cloud
                const unsignedUploadPreset = 'jlchannel'; // El preset de carga sin firmar que creaste en Cloudinary
                // -------------------------------------------------------------

                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', unsignedUploadPreset);

                try {
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/auto/upload`, {
                        method: 'POST',
                        body: formData,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error al subir el archivo a Cloudinary:", errorData);
                        showMessage(`Error al subir el archivo: ${errorData.error.message || 'Error desconocido'}`, 'error');
                        return;
                    }

                    const data = await response.json();
                    const downloadURL = data.secure_url;
                    console.log('Archivo disponible en Cloudinary:', downloadURL);

                    const normalizedActiveChannel = activeChannel.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    await window.addDoc(messagesColRef, {
                        text: downloadURL,
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                        fileUrl: downloadURL,
                        fileName: file.name,
                        fileType: file.type,
                    });

                    setCurrentMessage('');
                    showMessage('Archivo subido con éxito y enviado al chat.', 'success');
                    scrollToBottom();

                } catch (error) {
                    console.error("Error en la subida a Cloudinary (catch general):", error);
                    showMessage(`Error al iniciar la subida: ${error.message || 'Error desconocido'}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [activeChannel, isAuthReady, db, userId, userName, showMessage, setIsLoading, scrollToBottom]);


            // PWA: Manejador para el botón de instalación
            const handleInstallClick = React.useCallback(async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    setDeferredPrompt(null);
                }
            }, [deferredPrompt]);

            const renderHomePage = () => (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-600 to-blue-500 p-4 font-inter">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">CHANNEL</h1>

                        {deferredPrompt && !isPwaInstalled && (
                            <button
                                onClick={handleInstallClick}
                                className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-3"
                            >
                                Instalar App
                            </button>
                        )}

                        <div className="mb-6">
                            <label htmlFor="username-input" className="block text-gray-700 text-sm font-bold mb-2">
                                Tu Nombre de Usuario:
                            </label>
                            <div className="flex gap-2">
                                <input
                                    id="username-input"
                                    type="text"
                                    placeholder="Nombre de usuario"
                                    className="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-lg"
                                    value={userName}
                                    onChange={(e) => {
                                        setUserName(e.target.value);
                                        // When username changes, reset confirmation and Tigre related states
                                        setUserNameConfirmed(false);
                                        setIsTigre(false);
                                        setShowTigreCodeInput(false);
                                        setTigreCode('');
                                    }}
                                    maxLength="48"
                                    disabled={userNameConfirmed}
                                />
                                {!userNameConfirmed && (
                                    <button
                                        onClick={handleConfirmUserName}
                                        className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Confirmar
                                    </button>
                                )}
                                {userNameConfirmed && (
                                    <button
                                        onClick={() => {
                                            setUserNameConfirmed(false);
                                            setIsTigre(false);
                                            setShowTigreCodeInput(false);
                                            setTigreCode('');
                                            if (db && userId) {
                                                const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                                                window.setDoc(userProfileRef, { isTigreActive: false }, { merge: true }).catch(e => console.error("Error al desactivar Tigre en Firestore:", e));
                                            }
                                        }}
                                        className="bg-gray-400 hover:bg-400 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Editar
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* NEW LOGIC: showTigreCodeInput is now controlled by handleConfirmUserName */}
                        {userNameConfirmed && userName.trim() === 'Julian360' && showTigreCodeInput && !isTigre && (
                            <div className="mt-6 p-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-lg">
                                <p className="mb-2 font-semibold">Modo Tigre: Ingresa el código de 8 dígitos para habilitar.</p>
                                <input
                                    type="password"
                                    placeholder="Código de 8 dígitos"
                                    className="w-full p-3 border border-yellow-400 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 text-lg mb-3"
                                    value={tigreCode}
                                    onChange={(e) => setTigreCode(e.target.value)}
                                    maxLength="8"
                                />
                                <button
                                    onClick={handleTigreCodeSubmit}
                                    className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                >
                                    Confirmar Código
                                </button>
                            </div>
                        )}
                        {isTigre && (
                            <div className="mt-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg">
                                <p className="font-semibold">¡Modo Tigre Activado!</p>
                            </div>
                        )}

                        <div className="mb-6">
                            <input
                                id="channel-name-input"
                                ref={channelInputRef}
                                type="text"
                                placeholder="Nombre de canal"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg"
                                value={channelName}
                                onChange={(e) => setChannelName(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleCreateChannel();
                                    }
                                }}
                                maxLength="128"
                                disabled={!userNameConfirmed}
                            />
                        </div>

                        <button
                            onClick={handleCreateChannel}
                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-4"
                            disabled={!userNameConfirmed}
                        >
                            Ingresar
                        </button>

                        <button
                            onClick={() => setCurrentPage('explore')}
                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl"
                            disabled={!userNameConfirmed}
                        >
                            Explorar Canales
                        </button>
                    </div>
                </div>
            );

            const renderChannelPage = () => (
                <div className="relative flex flex-col items-center min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 font-inter">
                    <div className="h-full bg-white p-4 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-6 mb-2 pb-1 relative">
                        <h1
                            className="text-4xl font-extrabold text-gray-800 mb-2 cursor-pointer"
                            onClick={() => copyToClipboard(activeChannel)}
                        >
                            Canal: <span className="text-blue-600">{activeChannel}</span>
                        </h1>
                        <p className="text-lg text-gray-600 mb-2">Usuario: <span className="font-bold text-purple-600">{userName}</span></p>

                        <div className="absolute top-4 right-4" ref={optionsMenuRef}>
                            <button
                                onClick={() => setShowOptionsMenu(!showOptionsMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Opciones del canal"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showOptionsMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { handleToggleCamera(); setShowOptionsMenu(false); }}>Stream 🎥</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={handleAttachFile}>Adjuntar Archivo 📎</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setShowActivityPanel(true); setShowOptionsMenu(false); }}>Actividad 👥</button>
                                </div>
                            )}
                        </div>

                        <div id="daily-video-container" className={`relative w-full aspect-video bg-black rounded-lg overflow-hidden mb-4 ${isStreaming ? 'block' : 'hidden'}`}>
                        </div>

                        <div className="mb-1 w-full bg-gray-100 p-1 rounded-xl shadow-inner border border-gray-200">
                            <div className="h-[70vh] md:h-[66vh] bg-white rounded-lg p-2 overflow-y-auto border border-gray-300 mb-1 flex flex-col" style={{ minHeight: '100px' }}>
                                {chatMessages.length > 0 ? (
                                    chatMessages.map((msg) => (
                                        <div key={msg.id} className={`mb-2 p-2 rounded-lg ${msg.senderId === userId ? 'bg-blue-100 self-end text-right' : 'bg-gray-200 self-start text-left'}`} style={{ maxWidth: '80%' }}>
                                            <p className="font-semibold text-xs">{msg.senderId === userId ? 'Tú' : msg.senderUserName}</p>
                                            {msg.fileUrl ? (
                                                msg.fileType && msg.fileType.startsWith('image/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block">
                                                        <img src={msg.fileUrl} alt={msg.fileName || 'Imagen adjunta'} className="max-w-xs max-h-32 rounded-lg object-contain mb-1" />
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🖼️ {msg.fileName || 'Imagen Adjunta'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('audio/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block w-full max-w-sm">
                                                        <audio controls src={msg.fileUrl} className="w-full mb-1"></audio>
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🎵 {msg.fileName || 'Audio Adjunto'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('video/') ? (
                                                    <div className="flex flex-col items-start">
                                                        <p className="text-sm md:text-base text-gray-800 mb-1">
                                                            ▶️ <strong>Video</strong>
                                                        </p>
                                                        <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                            {msg.fileName || 'Video Adjunto'}
                                                        </a>
                                                    </div>
                                                ) : (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                        📎 {msg.fileName || 'Archivo Adjunto'}
                                                    </a>
                                                )
                                            ) : (
                                                <p className="text-sm md:text-base text-gray-800">{msg.text}</p>
                                            )}
                                            <p className="text-xs text-gray-500 mt-1">
                                                {msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Enviando...'}
                                            </p>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-500 italic m-auto">Sé el primero en enviar un mensaje.</p>
                                )}
                                <div ref={chatMessagesEndRef} />
                            </div>
                            <input
                                type="text"
                                placeholder="Escribe tu mensaje..."
                                className="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                                value={currentMessage}
                                onChange={(e) => setCurrentMessage(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleSendMessage();
                                    }
                                }}
                                disabled={!isAuthReady || !db || !userId}
                            />
                            <input
                                type="file"
                                id="file-upload-input"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                onChange={onFileSelected}
                            />
                        </div>

                        {dailyError && (
                            <div className="mt-4 text-red-500">
                                Error de Daily.co: {dailyError.message || "Un error desconocido ocurrió."}
                            </div>
                        )}
                    </div>

                    {showActivityPanel && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-end z-40">
                            <div className="bg-white w-full max-w-xs p-6 rounded-l-2xl shadow-lg flex flex-col">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800">Actividad del Canal</h2>
                                    <button
                                        onClick={() => setShowActivityPanel(false)}
                                        className="text-gray-500 hover:text-gray-700 text-3xl font-bold"
                                    >
                                        &times;
                                    </button>
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 mb-3">Miembros del Canal:</h3>
                                <div className="flex-grow overflow-y-auto">
                                    {channelMembers.length > 0 ? (
                                        <ul className="space-y-2">
                                            {channelMembers.map((member) => (
                                                <li key={member.id} className="flex items-center text-gray-700">
                                                    <span className="font-medium">{member.userName}</span>
                                                    {onlineParticipants.has(member.id) && (
                                                        <span className="ml-2 w-3 h-3 bg-green-500 rounded-full" title="Online"></span>
                                                    )}
                                                </li>
                                            ))}
                                        </ul>
                                    ) : (
                                        <p className="text-gray-500 italic">No hay miembros registrados aún.</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );

            const renderExplorePage = () => (
                <div className="flex flex-col items-center justify-start min-h-screen bg-gradient-to-br from-teal-500 to-cyan-600 p-4 font-inter">
                    <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-8 relative">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">Explorar Canales</h1>
                        <p className="text-lg text-gray-600 mb-8"> </p>

                        <div className="absolute top-4 right-4" ref={exploreMenuRef}>
                            <button
                                onClick={() => setShowExploreMenu(!showExploreMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Opciones de exploración"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showExploreMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('activity'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Mayor actividad
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('recent'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Más Recientes
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => {
                                            setShowSearchInput(!showSearchInput);
                                            setShowExploreMenu(false);
                                            setSortOption('none');
                                        }}
                                    >
                                        Buscar canal
                                    </button>
                                </div>
                            )}
                        </div>

                        {showSearchInput && (
                            <div className="mb-6 mt-4">
                                <input
                                    type="text"
                                    placeholder="Buscar canal por nombre..."
                                    className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 text-lg"
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    ref={searchInputRef}
                                />
                            </div>
                        )}

                        {availableChannels.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {availableChannels.map((channel) => (
                                    <div key={channel.id} className="bg-gray-100 p-4 rounded-lg shadow-md flex flex-col items-center justify-between">
                                        <h3 className="text-xl font-semibold text-gray-800 mb-2">{channel.name}</h3>
                                        <p className="text-sm text-gray-600 mb-3">
                                            Creado por: {channel.creatorUserName || 'Desconocido'}
                                        </p>
                                        <button
                                            onClick={() => handleJoinChannelFromExplore(channel)}
                                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mb-2"
                                        >
                                            Unirse
                                        </button>
                                        {(userId === channel.createdBy || isTigre) && (
                                            <button
                                                onClick={() => handleDeleteChannel(channel.name)}
                                                className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300"
                                            >
                                                Eliminar Canal
                                            </button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-500 italic"> </p>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen flex flex-col">
                    <MessageDisplay message={message} type={messageType} onClose={() => setMessage(null)} />
                    {isLoading && <LoadingSpinner />}
                    {currentPage === 'home' ? renderHomePage() : (currentPage === 'channel' ? renderChannelPage() : renderExplorePage())}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
