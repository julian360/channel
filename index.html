<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHANNEL App (GitHub Pages)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="manifest" href="/channel/manifest.json">
    <link rel="apple-touch-icon" href="/channel/icons/icon-192x192.png">
    <meta name="theme-color" content="#2563eb">

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, addDoc, serverTimestamp, orderBy, getDocs, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // Global variables for Firebase configuration.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify({
            apiKey: "AIzaSyBELawPeUmP2tRaL19X7Tr6MRcI9oMgdSM",
            authDomain: "channel-jl.firebaseapp.com",
            projectId: "channel-jl",
            storageBucket: "channel-jl.firebasestorage.app",
            messagingSenderId: "350780625607",
            appId: "1:350780625607:web:a0275d6d6ee89b0813a4e2"
        });
        window.firebaseApp = initializeApp(JSON.parse(window.__firebase_config));
        window.db = getFirestore(window.firebaseApp);
        window.auth = getAuth(window.firebaseApp);

        // Expose Firebase Firestore functions globally
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.orderBy = orderBy;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.signInAnonymously = signInAnonymously;
        window.deleteField = deleteField; // Expose deleteField

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/channel/service-worker.js')
                    .then(registration => console.log('Service Worker registrado: ', registration))
                    .catch(registrationError => console.log('Fallo el registro del Service Worker: ', registrationError));
            });
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .back-button-z-index { z-index: 60 !important; position: relative; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Debug message to verify code version
        console.log("DEBUG PROFUNDO: Code version: 2025-07-21-FinalFix-v102 (Firestore Cleanup Fix)");

        const generateRandomUserName = () => {
            const adjectives = ['Veloz', 'Sabio', 'Curioso', 'Audaz', 'Brillante', 'Silencioso', 'Fuerte', 'Gentil', 'Salvaje', 'Lujurioso', 'Hambriento', 'Envidioso', 'Furioso', 'Chad', 'Grande', 'Venoso', 'Oscuro', 'Chiquito'];
            const nouns = ['Lobo', 'Zorro', 'Águila', 'Tigre', 'Oso', 'Panda', 'Delfín', 'León', 'Perro', 'Gato', 'Puma', 'Pichón', 'Gorrión', 'Caballo', 'Gorila', 'Pinguino', 'Hombre', 'Mono', 'Ratón'];
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNumber = Math.floor(Math.random() * 1000);
            return `${randomAdjective}${randomNoun}${randomNumber}`;
        };

        const MessageDisplay = ({ message, type, onClose }) => {
            if (!message) return null;
            const bgColor = type === 'error' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-green-100 border-green-400 text-green-700';
            const borderColor = type === 'error' ? 'border-red-500' : 'border-green-500';
            return (
                <div className={`fixed top-4 right-4 p-4 rounded-lg shadow-lg flex items-center justify-between z-50 ${bgColor} border ${borderColor}`}>
                    <p className="font-semibold">{message}</p>
                    <button onClick={onClose} className="ml-4 text-lg font-bold">&times;</button>
                </div>
            );
        };

        const LoadingSpinner = () => (
            <div className="fixed inset-0 flex items-center justify-center z-50">
                <div style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)', padding: '20px', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <div className="spinner"></div>
                    <p className="ml-4 text-white text-lg">Cargando...</p>
                </div>
            </div>
        );

        const App = () => {
            const [currentPage, setCurrentPage] = React.useState('home');
            const [channelName, setChannelName] = React.useState('');
            const [activeChannel, setActiveChannel] = React.useState(null);
            const [availableChannels, setAvailableChannels] = React.useState([]);
            const [userName, setUserName] = React.useState('');
            const [userNameConfirmed, setUserNameConfirmed] = React.useState(false);
            const [message, setMessage] = React.useState(null);
            const [messageType, setMessageType] = React.useState('');
            const [currentMessage, setCurrentMessage] = React.useState('');
            const [chatMessages, setChatMessages] = React.useState([]);
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [userId, setUserId] = React.useState(null);
            const [isAuthReady, setIsAuthReady] = React.useState(false);
            const [isLoading, setIsLoading] = React.useState(true);
            const [showOptionsMenu, setShowOptionsMenu] = React.useState(false);
            const [showActivityPanel, setShowActivityPanel] = React.useState(false);
            const [channelMembers, setChannelMembers] = React.useState([]);
            const [localStream, setLocalStream] = React.useState(null);
            const [remoteStream, setRemoteStream] = React.useState(null);
            const [isStreaming, setIsStreaming] = React.useState(false);
            const [isReceivingStream, setIsReceivingStream] = React.useState(false);
            const [isStreamer, setIsStreamer] = React.useState(false);
            const [isStartingStream, setIsStartingStream] = React.useState(false);
            const [deferredPrompt, setDeferredPrompt] = React.useState(null);
            const [isPwaInstalled, setIsPwaInstalled] = React.useState(false);
            const [showTigreCodeInput, setShowTigreCodeInput] = React.useState(false);
            const [tigreCode, setTigreCode] = React.useState('');
            const [isTigre, setIsTigre] = React.useState(false);
            const [sortOption, setSortOption] = React.useState('activity');
            const [showExploreMenu, setShowExploreMenu] = React.useState(false);
            const [searchQuery, setSearchQuery] = React.useState('');
            const [showSearchInput, setShowSearchInput] = React.useState(false);
            const [isRemoteVideoReady, setIsRemoteVideoReady] = React.useState(false);
            const [isPlaybackStarted, setIsPlaybackStarted] = React.useState(false);

            const channelInputRef = React.useRef(null);
            const chatMessagesEndRef = React.useRef(null);
            const optionsMenuRef = React.useRef(null);
            const exploreMenuRef = React.useRef(null);
            const fileInputRef = React.useRef(null);
            const localVideoRef = React.useRef(null);
            const remoteVideoRef = React.useRef(null);
            const peerConnectionRef = React.useRef(null);
            const searchInputRef = React.useRef(null);
            const webrtcListenersRef = React.useRef({ offer: null, candidates: null });

            const showMessage = React.useCallback((msg, type = 'success') => {
                setMessage(msg);
                setMessageType(type);
                setTimeout(() => setMessage(null), 3000);
            }, []);

            const scrollToBottom = React.useCallback(() => {
                chatMessagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, []);
            
            const stopReceivingStream = React.useCallback(() => {
                console.log("DEBUG PROFUNDO (v102): stopReceivingStream initiated.");
                if (webrtcListenersRef.current.offer) {
                    webrtcListenersRef.current.offer();
                    webrtcListenersRef.current.offer = null;
                }
                if (webrtcListenersRef.current.candidates) {
                    webrtcListenersRef.current.candidates();
                    webrtcListenersRef.current.candidates = null;
                }

                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    setRemoteStream(null);
                }
                if (remoteVideoRef.current) {
                    remoteVideoRef.current.srcObject = null;
                }
                if (peerConnectionRef.current) {
                    peerConnectionRef.current.close();
                    peerConnectionRef.current = null;
                }
                setIsReceivingStream(false);
                setIsRemoteVideoReady(false); 
                setIsPlaybackStarted(false); 
                setIsLoading(false);
            }, [remoteStream]);

            const stopStreaming = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO (v102): stopStreaming initiated.");
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);
                }
                
                if (activeChannel && db && userId && !isStreamer && isReceivingStream) {
                    const normalizedActiveChannel = activeChannel.name.toLowerCase();
                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc_signaling`, 'webrtc_data');
                    await window.setDoc(webrtcDocRef, { answer: window.deleteField() }, { merge: true });
                    console.log("DEBUG PROFUNDO (v102): Viewer's answer field deleted from Firestore.");
                }

                stopReceivingStream(); 

                if (activeChannel && db && userId && isStreamer) {
                    const normalizedActiveChannel = activeChannel.name.toLowerCase();
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { isStreaming: false, streamerId: null, streamerUserName: null }, { merge: true });

                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc_signaling`, 'webrtc_data');
                    const candidatesColRef = window.collection(webrtcDocRef, 'candidates');
                    const candidatesSnapshot = await window.getDocs(candidatesColRef);
                    candidatesSnapshot.forEach(doc => window.deleteDoc(doc.ref));
                    await window.deleteDoc(webrtcDocRef).catch(()=>{});
                }
                setIsStreaming(false);
                setIsStreamer(false);
            }, [localStream, activeChannel, db, userId, isStreamer, isReceivingStream, stopReceivingStream]);

            React.useEffect(() => { setDb(window.db); setAuth(window.auth); }, []);

            React.useEffect(() => {
                if (!auth || !db) return;
                const unsubscribeAuth = window.onAuthStateChanged(auth, async (user) => {
                    let currentUserId = user ? user.uid : null;
                    if (!user) {
                        try {
                            const userCredential = await window.signInAnonymously(auth);
                            currentUserId = userCredential.user.uid;
                        } catch (anonError) {
                            console.error("Error during anonymous login:", anonError);
                            currentUserId = (Math.random().toString(36).substring(2) + Date.now().toString(36));
                            showMessage("Could not authenticate. Using fallback ID.", 'error');
                        }
                    }
                    setUserId(currentUserId);
                    if (currentUserId && db) {
                        const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${currentUserId}/profile`, 'userProfile');
                        try {
                            const userProfileSnap = await window.getDoc(userProfileRef);
                            let profileData;
                            if (userProfileSnap.exists()) {
                                profileData = userProfileSnap.data();
                            } else {
                                const userNameToUse = generateRandomUserName();
                                profileData = { userName: userNameToUse, isTigreActive: false };
                                await window.setDoc(userProfileRef, profileData);
                            }
                            setUserName(profileData.userName);
                            setUserNameConfirmed(true);
                            setIsTigre(profileData.isTigreActive === true);
                        } catch (profileError) {
                            console.error("Error loading/creating user profile:", profileError);
                            showMessage("Error loading your user profile.", 'error');
                        }
                    }
                    setIsAuthReady(true);
                    setIsLoading(false);
                });
                return () => unsubscribeAuth();
            }, [auth, db, showMessage]);
            
            const handleGoBack = React.useCallback(() => {
                console.log("DEBUG PROFUNDO (v102): Back button clicked. Cleaning up.");
                stopStreaming();
                setActiveChannel(null);
                setChatMessages([]);
                setChannelMembers([]);
                setCurrentPage('explore');
            }, [stopStreaming]);

            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state && event.state.page) {
                        setCurrentPage(event.state.page);
                        if (event.state.page !== 'channel') {
                            stopStreaming(); 
                        }
                    } else {
                        setCurrentPage('home');
                        stopStreaming();
                    }
                };

                window.addEventListener('popstate', handlePopState);
                if (currentPage && (!window.history.state || window.history.state.page !== currentPage)) {
                    window.history.pushState({ page: currentPage }, document.title, null);
                }
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [currentPage, stopStreaming]);

            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (optionsMenuRef.current && !optionsMenuRef.current.contains(event.target)) {
                        setShowOptionsMenu(false);
                        setShowActivityPanel(false);
                    }
                    if (exploreMenuRef.current && !exploreMenuRef.current.contains(event.target)) {
                        setShowExploreMenu(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [optionsMenuRef, exploreMenuRef]);

            const fetchChannels = React.useCallback(async () => {
                if (!isAuthReady || !db) return;
                setIsLoading(true);
                const channelsColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels`);
                const q = window.query(channelsColRef);

                try {
                    const snapshot = await window.getDocs(q);
                    const channelsData = snapshot.docs.map(doc => ({
                        id: doc.id,
                        name: doc.data().displayName || doc.id,
                        createdAt: doc.data().createdAt,
                        createdBy: doc.data().createdBy,
                        creatorUserName: doc.data().creatorUserName,
                        lastActivity: doc.data().lastActivity,
                        isStreaming: doc.data().isStreaming || false
                    }));

                    let processedChannels = [...channelsData];

                    if (sortOption === 'activity') {
                        processedChannels.sort((a, b) => {
                            const dateA = a.lastActivity ? a.lastActivity.toDate() : new Date(a.createdAt);
                            const dateB = b.lastActivity ? b.lastActivity.toDate() : new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    } else if (sortOption === 'recent') {
                        processedChannels.sort((a, b) => {
                            const dateA = new Date(a.createdAt);
                            const dateB = new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    }

                    if (searchQuery) {
                        processedChannels = processedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(searchQuery.toLowerCase())
                        );
                    }

                    setAvailableChannels(processedChannels);
                } catch (error) {
                    console.error("Error fetching channels:", error);
                    showMessage("Error loading channels.", 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, sortOption, searchQuery, showMessage]);

            React.useEffect(() => {
                let intervalId;
                if (currentPage === 'explore') {
                    fetchChannels();
                    intervalId = setInterval(fetchChannels, 60000);
                }
                return () => clearInterval(intervalId);
            }, [currentPage, fetchChannels]);

            React.useEffect(() => {
                if (showSearchInput && searchInputRef.current) {
                    searchInputRef.current.focus();
                }
            }, [showSearchInput]);
            
            const receiveStream = React.useCallback(async () => {
                if (!db || !userId || isReceivingStream || isStreaming) return;
                setIsReceivingStream(true);
                setIsLoading(true);
                setIsRemoteVideoReady(false);
                setIsPlaybackStarted(false);

                try {
                    const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "turn:openrelay.metered.ca:80", username: "openrelay@metered.ca", credential: "openrelay" }] };
                    const pc = new RTCPeerConnection(servers);
                    peerConnectionRef.current = pc;

                    pc.onconnectionstatechange = () => {
                        if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                            stopReceivingStream();
                        }
                    };

                    pc.ontrack = (event) => {
                        console.log("DEBUG PROFUNDO: Remote track received for viewer:", event.streams[0]);
                        setRemoteStream(event.streams[0]);
                    };
                    
                    pc.onicecandidate = async (event) => {
                        if (event.candidate) {
                            const normalizedChannelName = activeChannel.name.toLowerCase();
                            const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/webrtc_signaling`, 'webrtc_data');
                            const candidatesColRef = window.collection(webrtcDocRef, 'candidates');
                            await window.addDoc(candidatesColRef, { ...event.candidate.toJSON(), senderId: userId });
                        }
                    };

                } catch (error) {
                    console.error("Error receiving stream:", error);
                    showMessage("Error al recibir el stream.", 'error');
                    stopReceivingStream();
                } 
            }, [db, userId, userName, showMessage, isReceivingStream, isStreaming, stopReceivingStream, activeChannel]);

            // Main useEffect for channel data (chat, members)
            React.useEffect(() => {
                if (!isAuthReady || !db || !activeChannel || currentPage !== 'channel') {
                    setChatMessages([]);
                    setChannelMembers([]);
                    return;
                }
                const normalizedActiveChannel = activeChannel.name.toLowerCase();
                const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                const q = window.query(messagesColRef, window.orderBy('timestamp'));
                const unsubscribeMessages = window.onSnapshot(q, (snapshot) => {
                    const messagesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setChatMessages(messagesData);
                    scrollToBottom();
                });
                const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/members`);
                const unsubscribeMembers = window.onSnapshot(membersColRef, (snapshot) => {
                    const membersData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setChannelMembers(membersData);
                });
                return () => {
                    unsubscribeMessages();
                    unsubscribeMembers();
                };
            }, [isAuthReady, db, activeChannel, currentPage, scrollToBottom]);
            
            // useEffect for WebRTC Signaling (Listeners)
            React.useEffect(() => {
                if (isReceivingStream && activeChannel && db) {
                    const normalizedChannelName = activeChannel.name.toLowerCase();
                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/webrtc_signaling`, 'webrtc_data');
                    const candidatesColRef = window.collection(webrtcDocRef, 'candidates');
                    
                    const unsubscribeOffer = window.onSnapshot(webrtcDocRef, async (docSnap) => {
                        const pc = peerConnectionRef.current;
                        if (docSnap.exists() && pc) {
                            const data = docSnap.data();
                            if (data.offer && data.offer.senderId !== userId && !pc.currentRemoteDescription) {
                                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                await window.setDoc(webrtcDocRef, { answer: { ...pc.localDescription.toJSON(), receiverId: userId, receiverUserName: userName } }, { merge: true });
                                showMessage("Stream listo para reproducir.", 'success');
                            }
                        }
                    });

                    const unsubscribeCandidates = window.onSnapshot(candidatesColRef, (snapshot) => {
                        const pc = peerConnectionRef.current;
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === "added" && pc && pc.remoteDescription) {
                                if (change.doc.data().senderId !== userId) {
                                    await pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                                    await window.deleteDoc(change.doc.ref);
                                }
                            }
                        });
                    });

                    webrtcListenersRef.current = { offer: unsubscribeOffer, candidates: unsubscribeCandidates };
                    console.log("DEBUG PROFUNDO (v102): WebRTC listeners attached.");

                    return () => {
                        console.log("DEBUG PROFUNDO (v102): Cleanup for WebRTC listeners useEffect triggered.");
                        if (webrtcListenersRef.current.offer) {
                            webrtcListenersRef.current.offer();
                            webrtcListenersRef.current.offer = null;
                        }
                        if (webrtcListenersRef.current.candidates) {
                            webrtcListenersRef.current.candidates();
                            webrtcListenersRef.current.candidates = null;
                        }
                    };
                }
            }, [isReceivingStream, activeChannel, db, userId, userName, showMessage]);

            // useEffect to INITIATE stream viewing
            React.useEffect(() => {
                if (isAuthReady && db && activeChannel && currentPage === 'channel' && !isStreamer) {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, activeChannel.name.toLowerCase());
                    const unsubscribe = window.onSnapshot(channelDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const isChannelStreaming = docSnap.data().isStreaming || false;
                            if (isChannelStreaming && !isReceivingStream && !isStartingStream) {
                                showMessage(`Stream activo.`, 'info');
                                receiveStream();
                            } else if (!isChannelStreaming && isReceivingStream) {
                                showMessage("El stream ha terminado.", 'info');
                                stopReceivingStream();
                            }
                        }
                    });
                    return () => unsubscribe();
                }
            }, [isAuthReady, db, activeChannel, currentPage, isStreamer, isReceivingStream, isStartingStream, receiveStream, stopReceivingStream, showMessage]);


            const startStreaming = React.useCallback(async () => {
                 if (!db || !auth.currentUser || !activeChannel || !userName || isStartingStream || isStreaming || isReceivingStream) {
                    showMessage("No se puede iniciar el stream en este momento.", 'info');
                    return;
                }
                setIsStartingStream(true);
                setIsLoading(true);

                let stream;
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    setLocalStream(stream);

                    const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
                    const pc = new RTCPeerConnection(servers);
                    peerConnectionRef.current = pc;
                    
                    stream.getTracks().forEach(track => pc.addTrack(track, stream));

                    const normalizedActiveChannel = activeChannel.name.toLowerCase();
                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc_signaling`, 'webrtc_data');
                    const candidatesColRef = window.collection(webrtcDocRef, 'candidates');

                    pc.onicecandidate = event => event.candidate && window.addDoc(candidatesColRef, { ...event.candidate.toJSON(), senderId: auth.currentUser.uid });
                    
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    await window.setDoc(webrtcDocRef, { offer: { ...pc.localDescription.toJSON(), senderId: auth.currentUser.uid, senderUserName: userName } }, { merge: true });

                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { isStreaming: true, streamerId: auth.currentUser.uid, streamerUserName: userName }, { merge: true });

                    setIsStreaming(true);
                    setIsStreamer(true);
                    showMessage("Stream iniciado!", 'success');

                    const unsubscribeAnswer = window.onSnapshot(webrtcDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.answer && !pc.currentRemoteDescription) {
                                await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                            }
                        }
                    });

                    const unsubscribeCandidates = window.onSnapshot(candidatesColRef, (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === "added" && change.doc.data().senderId !== auth.currentUser.uid && pc.remoteDescription) {
                                await pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                                await window.deleteDoc(change.doc.ref);
                            }
                        });
                    });

                    return () => {
                        unsubscribeAnswer();
                        unsubscribeCandidates();
                    };

                } catch (error) {
                    console.error("Error starting stream:", error);
                    showMessage(`Error al iniciar stream: ${error.message}`, 'error');
                    if (stream) stream.getTracks().forEach(track => track.stop());
                    stopStreaming();
                } finally {
                    setIsStartingStream(false);
                    setIsLoading(false);
                }
            }, [db, auth, userName, activeChannel, isStartingStream, isStreaming, isReceivingStream, showMessage, stopStreaming]);

            // Effect to assign localStream to local video element
            React.useEffect(() => {
                if (localVideoRef.current && localStream && isStreamer) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream, isStreamer]);

            // Effect to assign remoteStream to remote video element
            React.useEffect(() => {
                if (remoteVideoRef.current && remoteStream && isReceivingStream) {
                    if (remoteVideoRef.current.srcObject !== remoteStream) {
                        remoteVideoRef.current.srcObject = remoteStream;
                    }
                } else if (remoteVideoRef.current) {
                    remoteVideoRef.current.srcObject = null;
                }
            }, [remoteStream, isReceivingStream]);
            
            const handleConfirmUserName = React.useCallback(async () => {
                if (userName.trim() === '' || userName.trim().length > 48) {
                    showMessage('Username must be between 1 and 48 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    showMessage("Authentication is not ready.", 'error');
                    return;
                }
                setIsLoading(true);
                try {
                    const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                    let profileUpdate = { userName: userName.trim(), isTigreActive: false };
                    await window.setDoc(userProfileRef, profileUpdate, { merge: true });
                    setUserNameConfirmed(true);
                    showMessage('Username confirmed!', 'success');
                    setIsTigre(false);
                    if (userName.trim() === 'Julian360') {
                        setShowTigreCodeInput(true);
                    } else {
                        setShowTigreCodeInput(false);
                    }
                } catch (error) {
                    console.error("Error saving username:", error);
                    showMessage("Error saving username.", 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage]);

            const handleTigreCodeSubmit = React.useCallback(async () => {
                if (parseInt(tigreCode) === (15476 * 1000 + 767)) {
                    setIsTigre(true);
                    showMessage('Tigre mode activated.', 'success');
                    setShowTigreCodeInput(false);
                    if (db && userId) {
                        try {
                            const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                            await window.setDoc(userProfileRef, { isTigreActive: true }, { merge: true });
                        } catch (error) {
                            console.error("Error activating Tigre mode in Firestore:", error);
                            showMessage("Error saving Tigre status.", 'error');
                        }
                    }
                } else {
                    showMessage('Incorrect code.', 'error');
                    setTigreCode('');
                }
            }, [tigreCode, showMessage, db, userId]);

            const handleCreateChannel = React.useCallback(async () => {
                if (channelName.trim() === '' || channelName.trim().length > 128) {
                    showMessage('Channel name must be between 1 and 128 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    showMessage("Authentication is not ready.", 'error');
                    return;
                }

                const normalizedChannelName = channelName.trim().toLowerCase();
                const originalChannelInput = channelName.trim();
                setIsLoading(true);
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                    const docSnap = await window.getDoc(channelDocRef);

                    if (docSnap.exists()) {
                        setActiveChannel({ name: docSnap.data().displayName || normalizedChannelName });
                    } else {
                        await window.setDoc(channelDocRef, {
                            name: normalizedChannelName,
                            displayName: originalChannelInput,
                            createdAt: new Date().toISOString(),
                            createdBy: userId,
                            creatorUserName: userName,
                            lastActivity: window.serverTimestamp(),
                            isStreaming: false,
                            streamerId: null
                        });
                        setActiveChannel({ name: originalChannelInput });
                    }
                    setCurrentPage('channel');
                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    await window.setDoc(memberDocRef, { userName: userName, joinedAt: window.serverTimestamp() }, { merge: true });
                } catch (error) {
                    console.error("Error creating/joining channel:", error);
                    showMessage("Error creating or joining channel.", 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [channelName, userName, isAuthReady, db, userId, showMessage]);
            
            const handleJoinChannelFromExplore = React.useCallback(async (channelToJoin) => {
                setActiveChannel(channelToJoin);
                setCurrentPage('channel');
                showMessage(`You have joined the channel: ${channelToJoin.name}`, 'success');

                if (!isAuthReady || !db || !userId || !userName) return;

                setIsLoading(true);
                try {
                    const normalizedChannelName = channelToJoin.name.toLowerCase();
                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    await window.setDoc(memberDocRef, { userName: userName, joinedAt: window.serverTimestamp() }, { merge: true });
                } catch (error) {
                    console.error("Error adding member:", error);
                    showMessage("Error adding member to channel.", 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage]);

            const handleSendMessage = React.useCallback(async () => {
                if (currentMessage.trim() === '') return;
                if (!isAuthReady || !db || !userId || !activeChannel || !userName) {
                    showMessage("Cannot send message. Application not ready.", 'error');
                    return;
                }

                const normalizedActiveChannel = activeChannel.name.toLowerCase();
                try {
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    await window.addDoc(messagesColRef, {
                        text: currentMessage.trim(),
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                    });
                    setCurrentMessage('');
                    scrollToBottom();

                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { lastActivity: window.serverTimestamp() }, { merge: true });
                } catch (error) {
                    console.error("Error sending message:", error);
                    showMessage("Error sending message.", 'error');
                }
            }, [currentMessage, userName, activeChannel, isAuthReady, db, userId, showMessage, scrollToBottom]);

            const handleDeleteChannel = React.useCallback(async (channelDisplayName) => {
                const userConfirmed = await new Promise((resolve) => {
                    const confirmModal = document.createElement('div');
                    confirmModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    confirmModal.innerHTML = `
                        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
                            <p class="mb-4 text-lg">Are you sure you want to delete channel "${channelDisplayName}"?</p>
                            <button id="confirmDelete" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Yes, Delete</button>
                            <button id="cancelDelete" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                        </div>
                    `;
                    document.body.appendChild(confirmModal);
                    document.getElementById('confirmDelete').onclick = () => { document.body.removeChild(confirmModal); resolve(true); };
                    document.getElementById('cancelDelete').onclick = () => { document.body.removeChild(confirmModal); resolve(false); };
                });

                if (!userConfirmed) return;
                if (!isAuthReady || !db || !userId) {
                    showMessage("Cannot delete channel. Not authenticated.", 'error');
                    return;
                }

                const normalizedChannelId = channelDisplayName.toLowerCase();
                setIsLoading(true);
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelId);
                    const docSnap = await window.getDoc(channelDocRef);

                    if (!docSnap.exists()) {
                        showMessage("The channel does not exist.", 'error');
                        return;
                    }

                    if (isTigre || docSnap.data().createdBy === userId) {
                        const subcollections = ['messages', 'members', 'webrtc_signaling/webrtc_data/candidates', 'webrtc_signaling'];
                        for (const sub of subcollections) {
                            const subColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/${sub}`);
                            const snapshot = await window.getDocs(subColRef);
                            const deletePromises = snapshot.docs.map(d => window.deleteDoc(d.ref));
                            await Promise.all(deletePromises);
                        }
                        
                        const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/webrtc_signaling/webrtc_data`);
                        await window.deleteDoc(webrtcDocRef).catch(()=>{});

                        await window.deleteDoc(channelDocRef);
                        showMessage(`Channel "${channelDisplayName}" deleted!`, 'success');
                        setCurrentPage('explore');
                        fetchChannels();
                    } else {
                        showMessage("You do not have permission to delete this channel.", 'error');
                    }
                } catch (error) {
                    console.error("Error deleting channel:", error);
                    showMessage("Error deleting channel.", 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, userId, isTigre, showMessage, fetchChannels]);

            const copyToClipboard = React.useCallback((text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showMessage(`"${text}" copied to clipboard!`, 'success');
                } catch (err) {
                    showMessage('Error copying to clipboard.', 'error');
                }
                document.body.removeChild(textarea);
            }, [showMessage]);

            const handleAttachFile = React.useCallback(() => {
                if (fileInputRef.current) fileInputRef.current.click();
                setShowOptionsMenu(false);
            }, []);

            const onFileSelected = React.useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file || !isAuthReady || !db || !userId || !activeChannel) return;
                setIsLoading(true);
                const cloudName = 'dq527zvti';
                const unsignedUploadPreset = 'jlchannel';
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', unsignedUploadPreset);
                try {
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/auto/upload`, { method: 'POST', body: formData });
                    if (!response.ok) throw new Error('Upload failed');
                    const data = await response.json();
                    const normalizedActiveChannel = activeChannel.name.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    await window.addDoc(messagesColRef, {
                        text: data.secure_url,
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                        fileUrl: data.secure_url,
                        fileName: file.name,
                        fileType: file.type,
                    });
                    showMessage('File sent.', 'success');
                } catch (error) {
                    console.error("Error uploading file:", error);
                    showMessage(`Error uploading file: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [activeChannel, isAuthReady, db, userId, userName, showMessage]);

            const handleInstallClick = React.useCallback(async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    await deferredPrompt.userChoice;
                    setDeferredPrompt(null);
                }
            }, []);

            const renderHomePage = () => (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-600 to-blue-500 p-4 font-inter">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">CHANNEL</h1>
                        <div className="mb-6">
                            <label htmlFor="username-input" className="block text-gray-700 text-sm font-bold mb-2">Your Username:</label>
                            <div className="flex gap-2">
                                <input id="username-input" type="text" placeholder="Username" className="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-lg" value={userName} onChange={(e) => { setUserName(e.target.value); setUserNameConfirmed(false); setIsTigre(false); setShowTigreCodeInput(false); setTigreCode(''); }} maxLength="48" disabled={userNameConfirmed} />
                                {!userNameConfirmed ? (
                                    <button onClick={handleConfirmUserName} className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300">Confirm</button>
                                ) : (
                                    <button onClick={() => { setUserNameConfirmed(false); setIsTigre(false); setShowTigreCodeInput(false); setTigreCode(''); if (db && userId) { const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile'); window.setDoc(userProfileRef, { isTigreActive: false }, { merge: true }); } }} className="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300">Edit</button>
                                )}
                            </div>
                        </div>
                        {userNameConfirmed && userName.trim() === 'Julian360' && showTigreCodeInput && !isTigre && (
                            <div className="mt-6 p-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-lg">
                                <p className="mb-2 font-semibold">Tigre Mode: Enter code.</p>
                                <input type="password" placeholder="8-digit code" className="w-full p-3 border border-yellow-400 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500" value={tigreCode} onChange={(e) => setTigreCode(e.target.value)} maxLength="8" />
                                <button onClick={handleTigreCodeSubmit} className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300 mt-2">Confirm Code</button>
                            </div>
                        )}
                        {isTigre && <div className="mt-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg"><p className="font-semibold">Tigre Mode Activated!</p></div>}
                        <div className="mb-6">
                            <input id="channel-name-input" ref={channelInputRef} type="text" placeholder="Channel name" className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg" value={channelName} onChange={(e) => setChannelName(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleCreateChannel()} maxLength="128" disabled={!userNameConfirmed} />
                        </div>
                        <button onClick={handleCreateChannel} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-4" disabled={!userNameConfirmed}>Enter</button>
                        <button onClick={() => setCurrentPage('explore')} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl" disabled={!userNameConfirmed}>Explore Channels</button>
                    </div>
                </div>
            );

            const renderChannelPage = () => (
                <div className="relative flex flex-col items-center min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 font-inter">
                    <div className="h-full bg-white p-4 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-6 mb-2 pb-1 relative">
                        <button onClick={handleGoBack} className="absolute top-4 left-4 text-blue-600 hover:text-blue-800 font-bold py-2 px-4 rounded-lg transition duration-300 z-10">
                            &larr; Back
                        </button>
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-2 cursor-pointer" onClick={() => copyToClipboard(activeChannel.name)}>
                            Channel: <span className="text-blue-600">{activeChannel.name}</span>
                        </h1>
                        <p className="text-lg text-gray-600 mb-2">User: <span className="font-bold text-purple-600">{userName}</span></p>

                        <div className="absolute top-4 right-4" ref={optionsMenuRef}>
                           <button onClick={() => setShowOptionsMenu(!showOptionsMenu)} className="text-gray-500 hover:text-gray-700 focus:outline-none" aria-label="Channel options">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>
                            </button>
                            {showOptionsMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    {isStreamer ? (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { stopStreaming(); setShowOptionsMenu(false); }}>Stop Stream ⏹️</button>
                                    ) : (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { startStreaming(); setShowOptionsMenu(false); }}>Stream 🎥</button>
                                    )}
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={handleAttachFile}>Attach File 📎</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setShowActivityPanel(true); setShowOptionsMenu(false); }}>Activity 👥</button>
                                </div>
                            )}
                        </div>

                        {(isStreaming || isReceivingStream) && (
                            <div className="relative w-full aspect-video bg-black rounded-lg mb-4 overflow-hidden">
                                {isStreamer && localStream && (
                                    <video ref={localVideoRef} autoPlay muted playsInline className="absolute inset-0 w-full h-full object-contain" style={{ transform: 'scaleX(-1)' }}></video>
                                )}
                                
                                {!isStreamer && isReceivingStream && (
                                    <video
                                        ref={remoteVideoRef}
                                        muted
                                        playsInline
                                        onLoadedMetadata={() => {
                                            console.log("DEBUG PROFUNDO (v102): onLoadedMetadata fired. Video is ready to play.");
                                            setIsRemoteVideoReady(true);
                                            setIsLoading(false);
                                        }}
                                        className="absolute inset-0 w-full h-full object-contain"
                                    ></video>
                                )}

                                {!isStreamer && isRemoteVideoReady && !isPlaybackStarted && (
                                    <button
                                        onClick={() => {
                                            const video = remoteVideoRef.current;
                                            if (video) {
                                                console.log(`DEBUG PROFUNDO (v102): Play button clicked.`);
                                                const playPromise = video.play();
                                                if (playPromise !== undefined) {
                                                    playPromise.then(() => {
                                                        console.log("DEBUG PROFUNDO (v102): Playback started successfully.");
                                                        video.muted = false;
                                                        setIsPlaybackStarted(true);
                                                    }).catch(error => {
                                                        console.error("DEBUG PROFUNDO (v102): Playback failed:", error);
                                                        showMessage(`Playback failed: ${error.name}. Please try again.`, "error");
                                                    });
                                                }
                                            }
                                        }}
                                        className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white text-xl font-bold rounded-lg cursor-pointer hover:bg-opacity-75"
                                    >
                                        ▶️ Play Stream
                                    </button>
                                )}
                            </div>
                        )}

                        <div className="mb-1 w-full bg-gray-100 p-1 rounded-xl shadow-inner border border-gray-200">
                           <div className="h-[70vh] md:h-[66vh] bg-white rounded-lg p-2 overflow-y-auto border border-gray-300 mb-1 flex flex-col" style={{ minHeight: '100px' }}>
                                {chatMessages.length > 0 ? (
                                    chatMessages.map((msg) => (
                                        <div key={msg.id} className={`mb-2 p-2 rounded-lg ${msg.senderId === userId ? 'bg-blue-100 self-end text-right' : 'bg-gray-200 self-start text-left'}`} style={{ maxWidth: '80%' }}>
                                            <p className="font-semibold text-xs">{msg.senderId === userId ? 'You' : msg.senderUserName}</p>
                                            {msg.fileUrl ? (
                                                msg.fileType?.startsWith('image/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block"><img src={msg.fileUrl} alt={msg.fileName || 'image'} className="max-w-xs max-h-32 rounded-lg object-contain mb-1" /><span className="text-blue-600 underline text-sm">🖼️ {msg.fileName || 'Image'}</span></a>
                                                ) : msg.fileType?.startsWith('audio/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block w-full max-w-sm"><audio controls src={msg.fileUrl} className="w-full mb-1"></audio><span className="text-blue-600 underline text-sm">🎵 {msg.fileName || 'Audio'}</span></a>
                                                ) : (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm">📎 {msg.fileName || 'File'}</a>
                                                )
                                            ) : (
                                                <p className="text-sm text-gray-800">{msg.text}</p>
                                            )}
                                            <p className="text-xs text-gray-500 mt-1">{msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Sending...'}</p>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-500 italic m-auto">Be the first to send a message.</p>
                                )}
                                <div ref={chatMessagesEndRef} />
                            </div>
                            <input type="text" placeholder="Write your message..." className="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" value={currentMessage} onChange={(e) => setCurrentMessage(e.target.value)} onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()} disabled={!isAuthReady} />
                            <input type="file" id="file-upload-input" ref={fileInputRef} style={{ display: 'none' }} onChange={onFileSelected} />
                        </div>
                    </div>

                    {showActivityPanel && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-end z-40">
                           <div className="bg-white w-full max-w-xs p-6 rounded-l-2xl shadow-lg flex flex-col">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800">Activity</h2>
                                    <button onClick={() => setShowActivityPanel(false)} className="text-gray-500 hover:text-gray-700 text-3xl font-bold">&times;</button>
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 mb-3">Members:</h3>
                                <div className="flex-grow overflow-y-auto">
                                    {channelMembers.length > 0 ? (
                                        <ul className="space-y-2">{channelMembers.map((member) => <li key={member.id} className="flex items-center text-gray-700"><span className="font-medium">{member.userName}</span></li>)}</ul>
                                    ) : (
                                        <p className="text-gray-500 italic">No members yet.</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );

            const renderExplorePage = () => (
                <div className="flex flex-col items-center justify-start min-h-screen bg-gradient-to-br from-teal-500 to-cyan-600 p-4 font-inter">
                    <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-8 relative">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">Explore Channels</h1>
                        <div className="absolute top-4 right-4" ref={exploreMenuRef}>
                            <button onClick={() => setShowExploreMenu(!showExploreMenu)} className="text-gray-500 hover:text-gray-700 focus:outline-none" aria-label="Explore options">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>
                            </button>
                            {showExploreMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setSortOption('activity'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}>Most Active</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setSortOption('recent'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}>Most Recent</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setShowSearchInput(!showSearchInput); setShowExploreMenu(false); setSortOption('none'); }}>Search Channel</button>
                                </div>
                            )}
                        </div>
                        {showSearchInput && (
                            <div className="mb-6 mt-4">
                                <input type="text" placeholder="Search by name..." className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 text-lg" value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} ref={searchInputRef} />
                            </div>
                        )}
                        {availableChannels.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {availableChannels.map((channel) => (
                                    <div key={channel.id} className="bg-gray-100 p-4 rounded-lg shadow-md flex flex-col items-center justify-between">
                                        <h3 className="text-xl font-semibold text-gray-800 mb-2">{channel.name}</h3>
                                        <p className="text-sm text-gray-600 mb-3">By: {channel.creatorUserName || 'Unknown'}</p>
                                        {channel.isStreaming && <span className="text-sm font-bold text-red-500 mb-2">🔴 LIVE</span>}
                                        <button onClick={() => handleJoinChannelFromExplore(channel)} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mb-2">Join</button>
                                        {(userId === channel.createdBy || isTigre) && (
                                            <button onClick={() => handleDeleteChannel(channel.name)} className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Delete</button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-500 italic">No channels available. Create one!</p>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen flex flex-col">
                    <MessageDisplay message={message} type={messageType} onClose={() => setMessage(null)} />
                    {isLoading && <LoadingSpinner />}
                    {currentPage === 'home' ? renderHomePage() : (currentPage === 'channel' ? renderChannelPage() : renderExplorePage())}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
