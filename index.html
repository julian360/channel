        // NEW: WebRTC: Function to start streaming (get camera/mic, create peer connection, offer)
        const startStreaming = React.useCallback(async () => { // Removed parameters from here
            console.log("DEBUG PROFUNDO: startStreaming - Initiated.");

            // Get the current user ID directly from Firebase Auth right before using it
            const currentAuthUser = auth.currentUser; // Use auth from state
            const currentAuthUserId = currentAuthUser ? currentAuthUser.uid : null;

            // Ensure auth and db are ready and currentAuthUserId is set
            if (!db || !currentAuthUserId || !activeChannel || !userName) { // Added userName check
                showMessage("Database or user information not ready. Cannot start stream.", 'error');
                console.warn("DEBUG PROFUNDO: startStreaming - DB, userId or userName not ready.");
                return;
            }

            // Prevent multiple stream attempts
            if (isStartingStream || isStreaming || isReceivingStream) {
                console.warn("DEBUG PROFUNDO: Stream already active or in process of starting. Aborting startStreaming.");
                showMessage("Ya hay un stream activo o en proceso de inicio.", 'info');
                return;
            }

            setIsStartingStream(true); // Set flag to true at the beginning
            setIsLoading(true); // Show loading spinner
            console.log("DEBUG PROFUNDO: startStreaming - isStartingStream set to true. isLoading set to true.");

            let pcInstance; // Use a local variable for the PC instance
            let stream; // Declare stream here

            try {
                // Get local media stream
                console.log("DEBUG PROFUNDO: Attempting to get user media (video and audio).");
                stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                setLocalStream(stream);
                if (localVideoRef.current) {
                    localVideoRef.current.srcObject = stream;
                    console.log("DEBUG PROFUNDO: Local video stream attached to video element.");
                }

                // WebRTC Peer Connection setup - NOW WITH XIRSYS TURN SERVERS
                const servers = {
                    iceServers: [
                        {
                            urls: [ "stun:eu-turn3.xirsys.com" ]
                        },
                        {
                            username: "O7tpKs7JoPXBgQzCEfvaK2zC-wicd4zk0jZpfeF3HyKScXVrwJhbpBbiOhzCAuBLAAAAAGh8zbdqdWxpYW4zNjA=",
                            credential: "978d21a4-6559-11f0-97ea-0242ac140004",
                            urls: [
                                "turn:eu-turn3.xirsys.com:80?transport=udp",
                                "turn:eu-turn3.xirsys.com:3478?transport=udp",
                                "turn:eu-turn3.xirsys.com:80?transport=tcp",
                                "turn:eu-turn3.xirsys.com:3478?transport=tcp",
                                "turns:eu-turn3.xirsys.com:443?transport=tcp",
                                "turns:eu-turn3.xirsys.com:5349?transport=tcp"
                            ]
                        }
                    ]
                };
                console.log("DEBUG PROFUNDO: RTCPeerConnection initialized with ICE servers:", servers);
                const newPeerConnection = new RTCPeerConnection(servers);
                setPeerConnection(newPeerConnection);

                // Add local stream tracks to the peer connection
                stream.getTracks().forEach(track => {
                    newPeerConnection.addTrack(track, stream);
                    console.log("DEBUG PROFUNDO: Added local track to peer connection:", track.kind);
                });

                // Normalize activeChannel for Firestore paths
                const normalizedActiveChannel = activeChannel.toLowerCase();

                // Handle ICE candidates
                newPeerConnection.onicecandidate = async (event) => {
                    if (event.candidate) {
                        console.log("DEBUG PROFUNDO: ICE Candidate found:", event.candidate);
                        // Save ICE candidate to Firestore
                        const candidateRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/${currentAuthUserId}/candidates`, event.candidate.sdpMid || 'video' + '_' + event.candidate.sdpMLineIndex + '_' + event.candidate.candidate.split(' ')[4]);
                        await window.setDoc(candidateRef, event.candidate.toJSON());
                        console.log("DEBUG PROFUNDO: ICE Candidate saved to Firestore:", event.candidate.toJSON());
                    } else {
                        console.log("DEBUG PROFUNDO: All ICE candidates gathered.");
                    }
                };

                // Handle remote stream when it arrives
                newPeerConnection.ontrack = (event) => {
                    console.log("DEBUG PROFUNDO: Remote track received:", event.streams[0]);
                    setRemoteStream(event.streams[0]);
                    if (remoteVideoRef.current) {
                        remoteVideoRef.current.srcObject = event.streams[0];
                        setIsReceivingStream(true);
                        console.log("DEBUG PROFUNDO: Remote stream attached to video element.");
                    }
                };

                // Create and set offer
                console.log("DEBUG PROFUNDO: Creating WebRTC offer.");
                const offer = await newPeerConnection.createOffer();
                await newPeerConnection.setLocalDescription(offer);
                console.log("DEBUG PROFUNDO: Local description (offer) set.");

                // Save offer to Firestore
                const offerRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc`, 'offer');
                await window.setDoc(offerRef, {
                    sdp: offer.sdp,
                    type: offer.type,
                    senderId: currentAuthUserId, // Use currentAuthUserId
                    senderUserName: userName, // Use userName
                    timestamp: window.serverTimestamp()
                });
                console.log("DEBUG PROFUNDO: WebRTC offer saved to Firestore:", offer.toJSON());

                // Update channel status in Firestore to indicate streaming
                const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                await window.setDoc(channelDocRef, {
                    isStreaming: true,
                    streamerId: currentAuthUserId, // Use currentAuthUserId
                    streamerUserName: userName, // Use userName
                    lastActivity: window.serverTimestamp()
                }, { merge: true });
                console.log("DEBUG PROFUNDO: Channel status updated in Firestore: isStreaming=true.");

                setIsStreaming(true);
                setIsStreamer(true); // Mark current user as streamer
                showMessage("Stream iniciado correctamente!", 'success');
                console.log("DEBUG PROFUNDO: Stream started successfully. isStreaming=true, isStreamer=true.");

                // Listen for answers from viewers
                const answerRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc`, 'answer');
                const unsubscribeAnswer = window.onSnapshot(answerRef, async (docSnap) => {
                    if (docSnap.exists() && docSnap.data().type === 'answer' && docSnap.data().receiverId === currentAuthUserId && !newPeerConnection.currentRemoteDescription) { // Use currentAuthUserId
                        const answer = new RTCSessionDescription(docSnap.data());
                        console.log("DEBUG PROFUNDO: Received answer from Firestore:", answer);
                        await newPeerConnection.setRemoteDescription(answer);
                        console.log("DEBUG PROFUNDO: Remote description (answer) set.");
                        showMessage("Respuesta de espectador recibida.", 'info');

                        // After setting the answer, collect and add ICE candidates from viewer
                        const viewerCandidatesRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/${docSnap.data().senderId}/candidates`);
                        const candidateSnapshot = await window.getDocs(viewerCandidatesRef);
                        candidateSnapshot.forEach(async (candidateDoc) => {
                            if (candidateDoc.exists()) {
                                try {
                                    const candidate = new RTCIceCandidate(candidateDoc.data());
                                    await newPeerConnection.addIceCandidate(candidate);
                                    console.log("DEBUG PROFUNDO: Added viewer ICE candidate:", candidate);
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error adding viewer ICE candidate:", e);
                                }
                            }
                        });
                    }
                }, (error) => {
                    console.error("DEBUG PROFUNDO: Error listening for answer:", error);
                });

                // Listen for candidates from viewers (after answer is set)
                const viewerCandidatesListener = window.onSnapshot(window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/viewerCandidates`), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === "added") {
                            const candidateData = change.doc.data();
                            if (candidateData.senderId !== currentAuthUserId) { // Use currentAuthUserId
                                try {
                                    const candidate = new RTCIceCandidate(candidateData);
                                    if (newPeerConnection.remoteDescription) { // Only add if remote description is set
                                        await newPeerConnection.addIceCandidate(candidate);
                                        console.log("DEBUG PROFUNDO: Added viewer candidate (via listener):", candidate);
                                    } else {
                                        console.log("DEBUG PROFUNDO: Remote description not set yet, deferring viewer candidate:", candidate);
                                    }
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error adding viewer candidate (via listener):", e);
                                }
                            }
                        }
                    });
                }, (error) => {
                    console.error("DEBUG PROFUNDO: Error listening for viewer candidates:", error);
                });

                // Clean up listeners when component unmounts or stream stops
                newPeerConnection.onconnectionstatechange = () => {
                    console.log(`DEBUG PROFUNDO: RTCPeerConnection state: ${newPeerConnection.connectionState}`);
                    if (newPeerConnection.connectionState === 'disconnected' || newPeerConnection.connectionState === 'failed' || newPeerConnection.connectionState === 'closed') {
                        console.log("DEBUG PROFUNDO: PeerConnection disconnected/failed/closed. Stopping stream.");
                        showMessage("Stream desconectado debido a un error de conexión.", 'error');
                        setTimeout(() => stopStreaming(), 500);
                        unsubscribeAnswer();
                        viewerCandidatesListener(); // Unsubscribe candidates listener
                    }
                };

                return () => {
                    unsubscribeAnswer();
                    viewerCandidatesListener(); // Unsubscribe candidates listener
                };

            } catch (error) {
                console.error("DEBUG PROFUNDO: Error starting stream:", error);
                showMessage("Error al iniciar el stream: " + error.message, 'error');
                if (stream) { // Use local 'stream' variable
                    stream.getTracks().forEach(track => track.stop());
                }
                if (peerConnection) { // Use state 'peerConnection'
                    peerConnection.close();
                }
                setLocalStream(null);
                setRemoteStream(null);
                setIsStreaming(false);
                setIsReceivingStream(false);
                setIsStreamer(false);
                setPeerConnection(null); // Ensure peerConnection is null on error
            } finally {
                setIsStartingStream(false); // Reset flag regardless of success or failure
                setIsLoading(false); // Hide loading spinner
                console.log("DEBUG PROFUNDO: startStreaming - Finally block executed. isStartingStream set to false. isLoading set to false.");
            }
        }, [db, userId, userName, showMessage, isStartingStream, isStreaming, isReceivingStream, localStream, peerConnection, activeChannel, auth]); // Added activeChannel and auth to dependencies
