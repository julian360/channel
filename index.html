<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHANNEL App (GitHub Pages)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="manifest" href="/channel/manifest.json">
    <link rel="apple-touch-icon" href="/channel/icons/icon-192x192.png">
    <meta name="theme-color" content="#2563eb">

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Import addDoc, getDocs, deleteDoc and serverTimestamp to add messages and timestamps
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, addDoc, serverTimestamp, orderBy, getDocs, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // Global variables for Firebase configuration.
        // IMPORTANT: In a real Canvas environment, these are provided automatically.
        // For local testing, your actual Firebase configuration details are now included below.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Replace 'default-app-id' if Canvas provides one
        // WARNING: If running locally and experiencing "Missing or insufficient permissions" errors,
        // ensure your Firestore security rules use 'default-app-id' in the /artifacts/{appId}/ path,
        // or configure window.__app_id to match your actual Canvas app ID if known.
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify({
            apiKey: "AIzaSyBELawPeUmP2tRaL19X7Tr6MRcI9oMgdSM", // Your Firebase API key
            authDomain: "channel-jl.firebaseapp.com", // Your Firebase authentication domain
            projectId: "channel-jl", // Your Firebase project ID
            storageBucket: "channel-jl.firebasestorage.app", // Your Firebase Storage Bucket
            messagingSenderId: "350780625607", // Your Firebase app ID
            appId: "1:350780625607:web:a0275d6d6ee89b0813a4e2" // Your Firebase app ID
        });
        window.firebaseApp = initializeApp(JSON.parse(window.__firebase_config));
        console.log("DEBUG PROFUNDO: window.firebaseApp:", window.firebaseApp); // Log the full app object
        window.db = getFirestore(window.firebaseApp);
        window.auth = getAuth(window.firebaseApp);

        // Expose Firebase Firestore functions globally for the React component to use
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        // Expose new Firestore functions
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.orderBy = orderBy;
        window.getDocs = getDocs; // Expose getDocs for subcollection deletion
        window.deleteDoc = deleteDoc; // Expose deleteDoc for channel deletion
        window.deleteField = deleteField; // Expose deleteField for removing fields

        // NEW: Expose signInAnonymously globally
        window.signInAnonymously = signInAnonymously;


        // PWA: Register the Service Worker with the corrected path for your 'channel' repository
        // NOTE: Service Workers require HTTPS or localhost. If running directly from file:/// protocol, this will fail.
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/channel/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Fallo el registro del Service Worker: ', registrationError);
                    });
            });
        }
    </script>
    <style>
        /* Basic style for the body to apply the Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Spinner styles */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Style added for the back button to ensure it is clickable */
        .back-button-z-index {
            z-index: 60 !important; /* Higher than the spinner z-index (50) */
            position: relative; /* Ensures z-index is applied */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Debug message to verify code version
        console.log("DEBUG PROFUNDO: Code version: 2025-07-21-DailyFix-v90 (WebRTC Streaming - AbortError Fix)");


        // Helper function to generate a random username for new users
        const generateRandomUserName = () => {
            const adjectives = ['Veloz', 'Sabio', 'Curioso', 'Audaz', 'Brillante', 'Silencioso', 'Fuerte', 'Gentil', 'Salvaje', 'Lujurioso', 'Hambriento', 'Envidioso', 'Furioso', 'Chad', 'Grande', 'Venoso', 'Oscuro', 'Chiquito'];
            const nouns = ['Lobo', 'Zorro', 'Águila', 'Tigre', 'Oso', 'Panda', 'Delfín', 'León', 'Perro', 'Gato', 'Puma', 'Pichón', 'Gorrión', 'Caballo', 'Gorila', 'Pinguino', 'Hombre', 'Mono', 'Ratón'];
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNumber = Math.floor(Math.random() * 1000);
            return `${randomAdjective}${randomNoun}${randomNumber}`;
        };

        // Message component to display user feedback (replaces alert())
        const MessageDisplay = ({ message, type, onClose }) => {
            if (!message) return null;

            const bgColor = type === 'error' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-green-100 border-green-400 text-green-700';
            const borderColor = type === 'error' ? 'border-red-500' : 'border-green-500';

            return (
                <div className={`fixed top-4 right-4 p-4 rounded-lg shadow-lg flex items-center justify-between z-50 ${bgColor} border ${borderColor}`}>
                    <p className="font-semibold">{message}</p>
                    <button onClick={onClose} className="ml-4 text-lg font-bold">
                        &times;
                    </button>
                </div>
            );
        };

        // Loading spinner component
        const LoadingSpinner = () => (
            // This div is still the full-screen overlay (without its own background)
            <div className="fixed inset-0 flex items-center justify-center z-50">
                {/* This new div is the container for the spinner and text, and will have the semi-transparent background */}
                <div style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)', padding: '20px', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <div className="spinner"></div>
                    <p className="ml-4 text-white text-lg">Cargando...</p>
                </div>
            </div>
        );
        // Main application component
        const App = () => {
            // State to manage the current view: 'home', 'channel' or 'explore'
            const [currentPage, setCurrentPage] = React.useState('home');
            // State to store the channel name entered by the user
            const [channelName, setChannelName] = React.useState('');
            // State to store the active channel name when viewing a channel
            const [activeChannel, setActiveChannel] = React.useState(null); // Changed to null initially
            // State to store a list of available channels for the explore page
            const [availableChannels, setAvailableChannels] = React.useState([]);
            // State to store the display name chosen by the user
            const [userName, setUserName] = React.useState('');
            // State to track if the username has been confirmed
            const [userNameConfirmed, setUserNameConfirmed] = React.useState(false);
            // State to display messages to the user
            const [message, setMessage] = React.useState(null);
            const [messageType, setMessageType] = React.useState('');

            // NEW: State for the current message being typed
            const [currentMessage, setCurrentMessage] = React.useState('');
            // NEW: State for chat messages
            const [chatMessages, setChatMessages] = React.useState([]);

            // Firebase related states
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [userId, setUserId] = React.useState(null);
            const [isAuthReady, setIsAuthReady] = React.useState(false);
            // NEW: State for general loading status
            const [isLoading, setIsLoading] = React.useState(true);

            // State for options menu visibility (for the channel page)
            const [showOptionsMenu, setShowOptionsMenu] = React.useState(false);
            // NEW: State for activity panel visibility (user list)
            const [showActivityPanel, setShowActivityPanel] = React.useState(false);
            // NEW: State to store channel members (historical)
            const [channelMembers, setChannelMembers] = React.useState([]);

            // NEW: WebRTC states
            const [localStream, setLocalStream] = React.useState(null);
            const [remoteStream, setRemoteStream] = React.useState(null);
            const [isStreaming, setIsStreaming] = React.useState(false);
            const [isReceivingStream, setIsReceivingStream] = React.useState(false);
            const [isStreamer, setIsStreamer] = React.useState(false); // To identify the streamer
            // NEW: Flag to indicate if a stream is in the process of starting
            const [isStartingStream, setIsStartingStream] = React.useState(false);


            // PWA: State for the beforeinstallprompt event
            const [deferredPrompt, setDeferredPrompt] = React.useState(null);
            // PWA: State to know if the PWA is already installed
            const [isPwaInstalled, setIsPwaInstalled] = React.useState(false);

            // NEW: States for Tigre mode
            const [showTigreCodeInput, setShowTigreCodeInput] = React.useState(false); // Controls code input visibility
            const [tigreCode, setTigreCode] = React.useState(''); // Stores the entered code
            const [isTigre, setIsTigre] = React.useState(false); // Indicates if Tigre mode is active


            // Ref for the channel name input field
            const channelInputRef = React.useRef(null);
            // NEW: Ref for the chat messages div to enable auto-scrolling
            const chatMessagesEndRef = React.useRef(null);
            // Ref for the options menu button to handle external clicks (for the channel page)
            const optionsMenuRef = React.useRef(null);
            // NEW: Ref for the explore page menu
            const exploreMenuRef = React.useRef(null);
            // NEW: Ref for the hidden file input
            const fileInputRef = React.useRef(null);
            // NEW: Refs for local and remote video elements
            const localVideoRef = React.useRef(null);
            const remoteVideoRef = React.useRef(null);
            // NEW: Ref for PeerConnection instance
            const peerConnectionRef = React.useRef(null);


            // NEW: State for the sorting option on the explore page
            // 'activity' (most active/most recent), 'recent' (most recent by creation)
            const [sortOption, setSortOption] = React.useState('activity');
            // NEW: State to control the visibility of the explore menu
            const [showExploreMenu, setShowExploreMenu] = React.useState(false);
            // NEW: State for the search query on the explore page
            const [searchQuery, setSearchQuery] = React.useState('');
            // NEW: State to control the visibility of the search field
            const [showSearchInput, setShowSearchInput] = React.useState(false);
            // NEW: Ref for the search input
            const searchInputRef = React.useRef(null);


            // Function to display a message
            const showMessage = React.useCallback((msg, type = 'success') => {
                setMessage(msg);
                setMessageType(type);
                setTimeout(() => setMessage(null), 3000); // Clear the message after 3 seconds
            }, []);

            // NEW: Function to scroll to the end of chat messages
            const scrollToBottom = React.useCallback(() => {
                chatMessagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, []);

            // PWA: Handles the beforeinstallprompt event
            React.useEffect(() => {
                const handler = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    console.log('beforeinstallprompt event fired!');
                };
                window.addEventListener('beforeinstallprompt', handler);

                if (window.matchMedia('(display-mode: standalone)').matches) {
                    setIsPwaInstalled(true);
                }

                return () => window.removeEventListener('beforeinstallprompt', handler);
            }, []);

            // PWA: Handles the appinstalled event (when the user installs the PWA)
            React.useEffect(() => {
                const handleAppInstalled = () => {
                    setIsPwaInstalled(true);
                    setDeferredPrompt(null);
                    showMessage('Instalando CHANNEL App...', 'success');
                    console.log('PWA was installed');
                };
                window.addEventListener('appinstalled', handleAppInstalled);
                return () => window.removeEventListener('appinstalled', handleAppInstalled);
            }, [showMessage]);

            // Debugging useEffect to monitor isLoading and currentPage
            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: isLoading changed to: ${isLoading}`);
            }, [isLoading]);

            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: currentPage changed to: ${currentPage}`);
            }, [currentPage]);

            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: isStartingStream changed to: ${isStartingStream}`);
            }, [isStartingStream]);


            // 1. Initial Firebase setup and setting db/auth states
            React.useEffect(() => {
                // Set db and auth from window after global initialization
                setDb(window.db);
                setAuth(window.auth);
                console.log("DEBUG PROFUNDO: Firebase db and auth set in React state.");
            }, []); // Empty dependency array means this runs once on mount

            // 2. Firebase Auth listener and user profile loading (depends on 'auth' being set)
            React.useEffect(() => {
                if (!auth || !db) {
                    console.log("DEBUG PROFUNDO: Auth or DB not yet available for listener setup. Skipping.");
                    return;
                }

                console.log("DEBUG PROFUNDO: Setting up onAuthStateChanged listener.");
                const unsubscribeAuth = window.onAuthStateChanged(auth, async (user) => {
                    let currentUserId = null;
                    if (user) {
                        currentUserId = user.uid;
                        setUserId(currentUserId);
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - userId established:", currentUserId);
                    } else {
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - User not authenticated, attempting signInAnonymously if necessary.");
                        try {
                            const userCredential = await window.signInAnonymously(auth); // Use auth from state
                            currentUserId = userCredential.user.uid;
                            setUserId(currentUserId);
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - ANONYMOUS userId established after signIn:", currentUserId);
                        } catch (anonError) {
                            console.error("DEBUG PROFUNDO: Error during anonymous login in onAuthStateChanged:", anonError);
                            // Fallback to a client-side generated ID if anonymous sign-in fails
                            currentUserId = (Math.random().toString(36).substring(2) + Date.now().toString(36));
                            setUserId(currentUserId);
                            showMessage("Could not authenticate user. Using fallback ID. Some functions might be limited.", 'error');
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - Fallback userId established due to login error:", currentUserId);
                        }
                    }

                    // *** KEY MODIFICATION HERE: Ensure db and userId are available before interacting with Firestore ***
                    if (currentUserId && db) { // Use db from state
                        const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${currentUserId}/profile`, 'userProfile');
                        try {
                            console.log("DEBUG PROFUNDO: Attempting to read/create user profile at path:", userProfileRef.path);
                            const userProfileSnap = await window.getDoc(userProfileRef);

                            let profileData;
                            if (userProfileSnap.exists()) {
                                profileData = userProfileSnap.data();
                                console.log(`DEBUG PROFUNDO: User profile loaded for ${currentUserId}.`);
                            } else {
                                // If profile doesn't exist, create it with a new random one
                                const userNameToUse = generateRandomUserName();
                                profileData = {
                                    userName: userNameToUse,
                                    isTigreActive: false
                                };
                                await window.setDoc(userProfileRef, profileData);
                                // No need to set localStorage here, userName state will be set below
                                console.log(`DEBUG PROFUNDO: User profile created for ${currentUserId}.`);
                            }

                            // Update React states based on the loaded/created profile data
                            setUserName(profileData.userName);
                            setUserNameConfirmed(true); // User name is confirmed if profile exists
                            setIsTigre(profileData.isTigreActive === true); // Ensure boolean true

                            // IMPORTANT: showTigreCodeInput is NOT set here anymore.
                            // It will be triggered by handleConfirmUserName if userName is 'Julian360'.

                        } catch (profileError) {
                            console.error("DEBUG PROFUNDO: Error loading/creating user profile from Firestore (inside onAuthStateChanged):", profileError);
                            setIsTigre(false);
                            setShowTigreCodeInput(false); // Ensure this is false on error
                            showMessage("Error loading your user profile. Check the console.", 'error');
                        }
                    } else {
                        // Fallback if currentUserId or db is not available, ensure Tigre mode is off
                        setIsTigre(false);
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: No userId or db available to load profile. isTigre set to false.");
                    }
                    setIsAuthReady(true);
                    setIsLoading(false);
                    console.log("DEBUG PROFUNDO: isAuthReady set to true.");
                });

                return () => unsubscribeAuth();
            }, [auth, db, showMessage]); // Dependencies: auth and db states


            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state && event.state.page) {
                        setCurrentPage(event.state.page);
                        // Stop streaming if navigating away from channel page
                        if (event.state.page !== 'channel') {
                            console.log("DEBUG PROFUNDO: handlePopState - Navigating away from channel. Initiating stream cleanup.");
                            stopStreaming(); // Call stopStreaming to clean up WebRTC
                        }
                    } else {
                        setCurrentPage('home');
                        // Stop streaming if navigating away from channel page
                        console.log("DEBUG PROFUNDO: handlePopState - Navigating to home. Initiating stream cleanup.");
                        stopStreaming(); // Call stopStreaming to clean up WebRTC
                    }
                };

                window.addEventListener('popstate', handlePopState);
                window.history.pushState({ page: currentPage }, document.title, null);
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [currentPage, stopStreaming]); // Added stopStreaming to dependencies

            React.useEffect(() => {
                if (currentPage && (!window.history.state || window.history.state.page !== currentPage)) {
                    window.history.pushState({ page: currentPage }, document.title, null);
                }
            }, [currentPage]);

            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (optionsMenuRef.current && !optionsMenuRef.current.contains(event.target)) {
                        setShowOptionsMenu(false);
                        setShowActivityPanel(false);
                    }
                    if (exploreMenuRef.current && !exploreMenuRef.current.contains(event.target)) {
                        setShowExploreMenu(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [optionsMenuRef, exploreMenuRef]);

            const fetchChannels = React.useCallback(async () => {
                if (!isAuthReady || !db) {
                    console.log("DEBUG PROFUNDO: fetchChannels - Firebase not ready or db is null. Exiting.");
                    return;
                }
                setIsLoading(true);
                console.log("DEBUG PROFUNDO: fetchChannels - Current db object:", db); // ADDED LOG
                console.log("DEBUG PROFUNDO: fetchChannels - Current auth.currentUser:", auth.currentUser); // ADDED LOG
                console.log("DEBUG PROFUNDO: fetchChannels - Using __app_id:", window.__app_id); // ADDED LOG
                const channelsColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels`);
                console.log("DEBUG PROFUNDO: fetchChannels - Attempting to get channels from path:", channelsColRef.path, "with userId:", userId); // MODIFIED LOG
                const q = window.query(channelsColRef);

                try {
                    const snapshot = await window.getDocs(q);
                    const channelsData = snapshot.docs.map(doc => ({
                        id: doc.id,
                        name: doc.data().displayName || doc.id,
                        createdAt: doc.data().createdAt,
                        createdBy: doc.data().createdBy,
                        creatorUserName: doc.data().creatorUserName,
                        lastActivity: doc.data().lastActivity,
                        isStreaming: doc.data().isStreaming || false // NEW: Add isStreaming status
                    }));

                    let processedChannels = [...channelsData];

                    if (sortOption === 'activity') {
                        processedChannels.sort((a, b) => {
                            const dateA = a.lastActivity ? a.lastActivity.toDate() : new Date(a.createdAt);
                            const dateB = b.lastActivity ? b.lastActivity.toDate() : new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    } else if (sortOption === 'recent') {
                        processedChannels.sort((a, b) => {
                            const dateA = new Date(a.createdAt);
                            const dateB = new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    }

                    if (searchQuery) {
                        processedChannels = processedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(searchQuery.toLowerCase())
                        );
                    }

                    setAvailableChannels(processedChannels);
                    console.log("DEBUG PROFUNDO: Channels fetched and processed:", processedChannels);
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error fetching channels:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error loading channels. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, auth, sortOption, searchQuery, showMessage, setIsLoading, setAvailableChannels, userId, window.__app_id]); // ADDED auth and window.__app_id to dependencies


            React.useEffect(() => {
                let intervalId;
                if (currentPage === 'explore') {
                    fetchChannels();
                    intervalId = setInterval(fetchChannels, 60000);
                }

                return () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                };
            }, [currentPage, fetchChannels]);


            React.useEffect(() => {
                if (showSearchInput && searchInputRef.current) {
                    searchInputRef.current.focus();
                }
            }, [showSearchInput]);


            // Main useEffect for channel data and Firestore listeners
            React.useEffect(() => {
                console.log("DEBUG PROFUNDO: Main Channel useEffect re-running. Dependencies:", { isAuthReady, db, activeChannel, currentPage, userId, isReceivingStream, localStream, isStreaming, isStartingStream, isStreamer });

                if (isAuthReady && db && activeChannel && currentPage === 'channel') {
                    const normalizedActiveChannel = activeChannel.name.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    const q = window.query(messagesColRef, window.orderBy('timestamp'));

                    const unsubscribe = window.onSnapshot(q, (snapshot) => {
                        const messagesData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChatMessages(messagesData);
                        scrollToBottom();
                        console.log("DEBUG PROFUNDO: Chat messages updated:", messagesData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching chat messages:", error);
                        if (error.code === 'unavailable' || error.code === 'permission-denied') {
                            showMessage("Connection error or permissions when loading messages. Check Firestore rules.", 'error');
                        } else {
                            showMessage("Error loading chat messages. Check the console.", 'error');
                        }
                    });

                    const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/members`);
                    const unsubscribeMembers = window.onSnapshot(membersColRef, (snapshot) => {
                        const membersData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChannelMembers(membersData);
                        console.log("DEBUG PROFUNDO: Channel members updated:", membersData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching channel members:", error);
                    });

                    // NEW: Listen for streaming status of the channel
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    const unsubscribeChannelStatus = window.onSnapshot(channelDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const channelData = docSnap.data();
                            const currentStreamerIdInFirestore = channelData.streamerId;
                            const isChannelStreamingInFirestore = channelData.isStreaming || false;

                            console.log("DEBUG PROFUNDO: onSnapshot - Channel data from Firestore:", channelData);
                            console.log("DEBUG PROFUNDO: onSnapshot - Channel streaming status in Firestore:", isChannelStreamingInFirestore, "Streamer ID in Firestore:", currentStreamerIdInFirestore, "Current User ID:", userId);
                            console.log("DEBUG PROFUNDO: onSnapshot - Local isStreaming:", isStreaming, "Local isReceivingStream:", isReceivingStream, "Local isStreamer:", isStreamer);

                            // Logic for viewers:
                            // If channel is streaming, there's a streamer ID, and it's not us, AND we are not already receiving a stream
                            if (isChannelStreamingInFirestore && currentStreamerIdInFirestore && currentStreamerIdInFirestore !== userId && !isReceivingStream) {
                                // Add a check here to ensure we are not in the process of starting our own stream.
                                // This is where isStartingStream is useful.
                                if (!isStartingStream) {
                                    showMessage(`Stream activo en este canal por ${channelData.streamerUserName || 'alguien'}. Uniéndote como espectador...`, 'info');
                                    console.log("DEBUG PROFUNDO: Attempting to join stream as viewer.");
                                    await receiveStream(normalizedActiveChannel, currentStreamerIdInFirestore); // Call receiveStream
                                } else {
                                    console.log("DEBUG PROFUNDO: onSnapshot - isStartingStream is true. Ignoring viewer join to prevent race condition during streamer setup.");
                                }
                            }
                            // Logic for viewers to stop receiving if stream ends
                            else if (!isChannelStreamingInFirestore && currentStreamerIdInFirestore !== userId && isReceivingStream) {
                                showMessage("El stream ha terminado.", 'info');
                                console.log("DEBUG PROFUNDO: Stream ended (viewer side).");
                                setTimeout(() => stopReceivingStream(), 500); // Call stopReceivingStream
                            }
                            // Logic for streamer to ensure their local state matches Firestore (if they stopped it elsewhere)
                            // This also handles cases where the streamer might have left the channel or their stream died
                            else if (isStreaming && isStreamer && (!isChannelStreamingInFirestore || currentStreamerIdInFirestore !== userId)) {
                                if (!isStartingStream) { // Only stop if we are not actively trying to start it
                                    console.warn("DEBUG PROFUNDO: Streamer local state is active, but Firestore shows inactive or different streamer. Forcing local stream stop.");
                                    console.trace("DEBUG PROFUNDO: Call stack for forced stopStreaming (streamer side).");
                                    showMessage("Tu stream ha terminado o ha sido desconectado (detectado por Firestore).", 'info');
                                    setTimeout(() => stopStreaming(), 500);
                                } else {
                                    console.log("DEBUG PROFUNDO: onSnapshot - Streamer is starting stream. Ignoring temporary Firestore state mismatch.");
                                }
                            }
                        }
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching channel streaming status:", error);
                        if (isStreaming || isReceivingStream) {
                            showMessage("Error al obtener el estado del stream. Deteniendo el stream.", 'error');
                            setTimeout(() => stopStreaming(), 500);
                        }
                    });


                    return () => {
                        unsubscribe();
                        unsubscribeMembers();
                        unsubscribeChannelStatus(); // Clean up listener
                        // This useEffect now ONLY cleans up Firestore listeners and related states.
                        // WebRTC cleanup is handled by the dedicated useEffect below.
                        setChatMessages([]);
                        setChannelMembers([]);
                        console.log("DEBUG PROFUNDO: Cleaning up channel messages and members states.");
                    };
                } else {
                    // If no active channel or not on channel page, ensure states are reset
                    setChatMessages([]);
                    setChannelMembers([]);
                    // REMOVED: The stopStreaming() call from here.
                    console.log("DEBUG PROFUNDO: Cleaning up channel messages and members states (no active channel).");
                }
            }, [isAuthReady, db, activeChannel, currentPage, showMessage, scrollToBottom, userId, isReceivingStream, localStream, isStreaming, isStartingStream, isStreamer, stopStreaming, stopReceivingStream]);


            // NEW: Dedicated useEffect for WebRTC stream cleanup
            React.useEffect(() => {
                // This effect will run when activeChannel or currentPage changes.
                // It ensures WebRTC resources are cleaned up when leaving the channel.
                if (!activeChannel || currentPage !== 'channel') {
                    if (isStreaming || isReceivingStream) {
                        console.log("DEBUG PROFUNDO: WebRTC cleanup useEffect triggered: Stopping active stream due to channel exit or page change.");
                        stopStreaming(); // This function handles all WebRTC cleanup
                    }
                }
            }, [activeChannel, currentPage, isStreaming, isReceivingStream, stopStreaming]); // Dependencies for this specific cleanup


            const handleConfirmUserName = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleConfirmUserName - Initiated.");
                if (userName.trim() === '') {
                    showMessage('Please enter a username.', 'error');
                    return;
                }
                if (userName.trim().length > 48) {
                    showMessage('Username cannot exceed 48 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleConfirmUserName - Firebase is not ready or db/userId is null.");
                    showMessage("Authentication is not ready. Please try again.", 'error');
                    return;
                }
                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleConfirmUserName - isLoading set to true.");
                try {
                    const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Attempting to save user profile.");
                    let profileUpdate = { userName: userName.trim() };

                    // Only set isTigreActive to false here, it will be set to true by handleTigreCodeSubmit
                    profileUpdate.isTigreActive = false;

                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Saving user profile:", { userId: userId, userName: userName.trim(), isTigreActive: profileUpdate.isTigreActive });
                    await window.setDoc(userProfileRef, profileUpdate, { merge: true });
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - User profile saved.");
                    // No need to set localStorage here, userName state is already updated
                    setUserNameConfirmed(true);
                    showMessage('Username confirmed!', 'success');
                    setIsTigre(profileUpdate.isTigreActive); // This will be false here

                    // NEW LOGIC: Only show Tigre code input IF userName is Julian360 AND isTigre is NOT active
                    if (userName.trim() === 'Julian360' && !profileUpdate.isTigreActive) {
                        setShowTigreCodeInput(true);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - User is Julian360 and Tigre mode inactive. Showing Tigre code input.");
                    } else {
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - User is NOT Julian360 or Tigre mode active. Hiding Tigre code input.");
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error saving username (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error saving username. Please try again.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage, setIsLoading, setShowTigreCodeInput, setIsTigre, setUserNameConfirmed]);

            const handleTigreCodeSubmit = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - current userId:", userId);
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Entered code:", tigreCode);
                if (parseInt(tigreCode) === (15476 * 1000 + 767)) {
                    setIsTigre(true);
                    showMessage('Tigre mode activated. You can now delete any channel.', 'success');
                    setShowTigreCodeInput(false);

                    if (db && userId) {
                        try {
                            const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Attempting to activate Tigre mode in Firestore for userId:", userId, "with isTigreActive: true (boolean).");
                            await window.setDoc(userProfileRef, { isTigreActive: true }, { merge: true });
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Tigre mode activated in Firestore for user:", userId);
                            const updatedProfileSnap = await window.getDoc(userProfileRef);
                            if (updatedProfileSnap.exists()) {
                                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - User profile READ after update:", updatedProfileSnap.data());
                            }
                        } catch (error) {
                            console.error("DEBUG PROFUNDO: handleTigreCodeSubmit - Error activating Tigre mode in Firestore:", error);
                            showMessage("Error saving Tigre status. Please try again.", 'error');
                        }
                    }

                } else {
                    showMessage('Incorrect code. Please try again.', 'error');
                    setTigreCode('');
                    console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Incorrect code.");
                }
            }, [tigreCode, showMessage, setIsTigre, setShowTigreCodeInput, setTigreCode, db, userId]);

            const handleCreateChannel = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleCreateChannel - Initiated.");
                if (channelName.trim() === '') {
                    showMessage('Please enter a name for the channel.', 'error');
                    if (channelInputRef.current) {
                        channelInputRef.current.focus();
                    }
                    return;
                }
                if (channelName.trim().length > 128) {
                    showMessage('Channel name cannot exceed 128 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleCreateChannel - Firebase is not ready yet. Please wait.");
                    showMessage("Authentication is not ready. Please try again.", 'error');
                    return;
                }

                const normalizedChannelName = channelName.trim().toLowerCase();
                const originalChannelInput = channelName.trim();

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleCreateChannel - isLoading set to true.");
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Attempting to get channel doc.");
                    const docSnap = await window.getDoc(channelDocRef);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Channel doc snap received.");

                    if (docSnap.exists()) {
                        const existingChannelDisplayName = docSnap.data().displayName || normalizedChannelName;
                        setActiveChannel({ name: existingChannelDisplayName }); // Set activeChannel as an object
                        setCurrentPage('channel');
                        showMessage(`You have joined the channel: ${existingChannelDisplayName}`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Existing channel joined:", existingChannelDisplayName);
                    } else {
                        await window.setDoc(channelDocRef, {
                            name: normalizedChannelName,
                            displayName: originalChannelInput,
                            createdAt: new Date().toISOString(),
                            createdBy: userId,
                            creatorUserName: userName,
                            lastActivity: window.serverTimestamp(),
                            isStreaming: false, // NEW: Initialize streaming status
                            streamerId: null // NEW: Initialize streamer ID
                        });
                        setActiveChannel({ name: originalChannelInput }); // Set activeChannel as an object
                        setCurrentPage('channel');
                        showMessage(`Channel "${originalChannelInput}" created and you have joined!`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Channel created and joined:", originalChannelInput);
                    }

                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Attempting to add member.");
                    await window.setDoc(memberDocRef, {
                        userName: userName,
                        joinedAt: window.serverTimestamp()
                    }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Member added. Setting isLoading to false.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error creating or joining channel (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error creating or joining channel. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [channelName, userName, isAuthReady, db, userId, showMessage, setIsLoading, setCurrentPage, setActiveChannel]);

            const handleJoinChannelFromExplore = React.useCallback(async (channelToJoin) => {
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Initiated for channel:", channelToJoin.name);
                setActiveChannel(channelToJoin); // activeChannel is already an object from availableChannels
                setCurrentPage('channel');
                showMessage(`You have joined the channel: ${channelToJoin.name}`, 'success');
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Joined channel:", channelToJoin.name);

                if (!isAuthReady || !db || !userId || !userName) {
                    console.warn("DEBUG PROFUNDO: handleJoinChannelFromExplore - Firebase, user, or username not ready. Cannot add member.");
                    return;
                }

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - isLoading set to true.");
                try {
                    const normalizedChannelName = channelToJoin.name.toLowerCase();
                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Attempting to add member.");
                    await window.setDoc(memberDocRef, {
                        userName: userName,
                        joinedAt: window.serverTimestamp()
                    }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Member added. Setting isLoading to false.");
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error adding member when joining channel (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error adding member to channel. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage, setCurrentPage, setActiveChannel]);

            const handleSendMessage = React.useCallback(async () => {
                if (currentMessage.trim() === '') {
                    return;
                }
                if (!isAuthReady || !db || !userId || !activeChannel || !userName) {
                    console.warn("DEBUG PROFUNDO: handleSendMessage - Firebase, user, channel or username are not ready. Cannot send message.");
                    showMessage("Could not send message. Application is not ready.", 'error');
                    return;
                }

                const normalizedActiveChannel = activeChannel.name.toLowerCase(); // Use activeChannel.name
                try {
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    console.log("DEBUG PROFUNDO: handleSendMessage - Sending message:", currentMessage.trim(), "to channel:", normalizedActiveChannel);
                    await window.addDoc(messagesColRef, {
                        text: currentMessage.trim(),
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                    });
                    setCurrentMessage('');
                    scrollToBottom();

                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { lastActivity: window.serverTimestamp() }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleSendMessage - Channel last activity updated.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error sending message:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions when sending message. Check Firestore rules.", 'error');
                    } else {
                        showMessage("Error sending message. Check the console.", 'error');
                    }
                }
            }, [currentMessage, userName, activeChannel, isAuthReady, db, userId, showMessage, scrollToBottom]);

        const handleDeleteChannel = React.useCallback(async (channelDisplayName) => {
                console.log("DEBUG PROFUNDO: handleDeleteChannel - current userId:", userId);
                console.log("DEBUG PROFUNDO: handleDeleteChannel - Initiating deletion for channel:", channelDisplayName);
                const userConfirmed = await new Promise((resolve) => {
                    const confirmModal = document.createElement('div');
                    confirmModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    confirmModal.innerHTML = `
                        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
                            <p class="mb-4 text-lg">Are you sure you want to delete channel "${channelDisplayName}"? This action is irreversible.</p>
                            <button id="confirmDelete" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Yes, Delete</button>
                            <button id="cancelDelete" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                        </div>
                    `;
                    document.body.appendChild(confirmModal);

                    document.getElementById('confirmDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(true);
                    };
                    document.getElementById('cancelDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(false);
                    };
                });

                if (!userConfirmed) {
                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Deletion canceled by user.");
                    return;
                }

                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleDeleteChannel - Firebase is not ready or db/userId is null. Cannot delete.");
                    showMessage("Firebase is not ready or you don't have a user ID. Cannot delete channel.", 'error');
                    return;
                }

                const normalizedChannelId = channelDisplayName.toLowerCase();

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleDeleteChannel - isLoading set to true.");
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelId);
                    const docSnap = await window.getDoc(channelDocRef);

                    if (!docSnap.exists()) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Channel does not exist.");
                        showMessage("The channel does not exist.", 'error');
                        setIsLoading(false);
                        return;
                    }

                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Values for permission evaluation:");
                    console.log("DEBUG PROFUNDO:   - userId (current):", userId);
                    console.log("DEBUG PROFUNDO:   - isTigre (React state):", isTigre);
                    console.log("DEBUG PROFUNDO:   - channel.createdBy (from Firestore):", docSnap.data().createdBy);
                    console.log("DEBUG PROFUNDO:   - userId === channel.createdBy?:", userId === docSnap.data().createdBy);

                    if (isTigre || docSnap.data().createdBy === userId) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permission GRANTED. Initiating subcollection and channel deletion.");

                        const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`);
                        const messagesSnapshot = await window.getDocs(messagesColRef);
                        const deleteMessagePromises = [];
                        messagesSnapshot.forEach(msgDoc => {
                            deleteMessagePromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`, msgDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Deleting ${deleteMessagePromises.length} messages.`);
                        await Promise.all(deleteMessagePromises);
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - All messages deleted.");

                        const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`);
                        const membersSnapshot = await window.getDocs(membersColRef);
                        const deleteMemberPromises = [];
                        membersSnapshot.forEach(memberDoc => {
                            deleteMemberPromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`, memberDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Deleting ${deleteMemberPromises.length} members.`);
                        await Promise.all(deleteMemberPromises);
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - All members deleted.");

                        // Delete WebRTC signaling data
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Checking for WebRTC signaling data."); // NEW LOG
                        const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/webrtc_signaling`, 'webrtc_data');
                        const webrtcDocSnap = await window.getDoc(webrtcDocRef);
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - webrtcDocSnap exists:", webrtcDocSnap.exists()); // NEW LOG

                        if (webrtcDocSnap.exists()) {
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - WebRTC signaling document exists. Proceeding with deletion."); // NEW LOG
                            // Delete candidates subcollection first
                            const candidatesColRef = window.collection(webrtcDocRef, 'candidates');
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - Getting WebRTC candidates."); // NEW LOG
                            const candidatesSnapshot = await window.getDocs(candidatesColRef);
                            const deleteCandidatePromises = [];
                            candidatesSnapshot.forEach(candidateDoc => {
                                deleteCandidatePromises.push(window.deleteDoc(window.doc(candidatesColRef, candidateDoc.id)));
                            });
                            console.log(`DEBUG PROFUNDO: handleDeleteChannel - Deleting ${deleteCandidatePromises.length} WebRTC candidates.`);
                            await Promise.all(deleteCandidatePromises);
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - All WebRTC candidates deleted.");

                            // Then delete the webrtc_data document itself
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - Deleting main WebRTC signaling document."); // NEW LOG
                            await window.deleteDoc(webrtcDocRef);
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - WebRTC signaling data cleared from Firestore.");
                        } else {
                            console.log("DEBUG PROFUNDO: handleDeleteChannel - No WebRTC signaling data found to delete.");
                        }


                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Attempting to delete main channel document:", normalizedChannelId);
                        await window.deleteDoc(channelDocRef); // <--- This line should delete the main channel document
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Main channel document DELETED successfully:", normalizedChannelId);

                        showMessage(`Channel "${channelDisplayName}" deleted successfully!`, 'success');
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Message shown, navigating to explore page."); // Modified log
                        setCurrentPage('explore'); // <--- MODIFIED: Navigate to explore page instead of full reload
                        // NEW: Force a refresh of the explore channels content
                        fetchChannels(); // <--- ADDED: Call fetchChannels to refresh the list
                    } else {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permission DENIED. Conditions not met.");
                        showMessage("You do not have permission to delete this channel.", 'error');
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error deleting channel (catch general):", error);
                    console.error("DEBUG PROFUNDO: Código de error:", error.code);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                        } else {
                        showMessage("Error deleting channel. Check the console.", 'error');
                    }
                    setIsLoading(false);
                } finally {
                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [isAuthReady, db, userId, isTigre, showMessage, setIsLoading, setCurrentPage, fetchChannels]); // ADDED fetchChannels to dependencies


            // WebRTC Functions
            // The createPeerConnection function is no longer needed as a separate useCallback.
            // Its logic is now integrated directly into startStreaming and receiveStream.

            // NEW: Function to request media permissions explicitly
            const requestMediaPermissions = React.useCallback(async () => {
                try {
                    console.log("DEBUG PROFUNDO: Requesting media permissions explicitly...");
                    // REMOVED: stream.getTracks().forEach(track => track.stop());
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    // Explicitly stop tracks to release camera/mic after permission check
                    stream.getTracks().forEach(track => track.stop());
                    showMessage("Camera and microphone permissions granted!", 'success');
                    console.log("DEBUG PROFUNDO: Media permissions successfully granted.");
                } catch (error) {
                    console.error(`DEBUG PROFUNDO: Error requesting media permissions: Name: ${error.name}, Message: ${error.message}`, error);
                    showMessage(`Error requesting media permissions: ${error.message}. Please check your browser settings.`, 'error');
                }
            }, [showMessage]);


            // WebRTC: Function to stop receiving stream
            const stopReceivingStream = React.useCallback(() => {
                console.log("DEBUG PROFUNDO: stopReceivingStream - Initiated.");
                if (remoteStream) {
                    remoteStream.getTracks().forEach(track => track.stop());
                    setRemoteStream(null);
                    console.log("DEBUG PROFUNDO: Remote stream tracks stopped and cleared.");
                }
                if (remoteVideoRef.current) { // Ensure remote video element is also cleared
                    remoteVideoRef.current.srcObject = null;
                    remoteVideoRef.current.muted = true;
                    remoteVideoRef.current.load();
                    console.log("DEBUG PROFUNDO: Remote video element srcObject cleared.");
                }
                if (peerConnectionRef.current) { // Use ref
                    peerConnectionRef.current.close();
                    peerConnectionRef.current = null; // Clear ref
                    console.log("DEBUG PROFUNDO: PeerConnection closed.");
                }
                setIsReceivingStream(false);
                setIsLoading(false); // Hide loading spinner if it was showing for receiving
                console.log("DEBUG PROFUNDO: stopReceivingStream - Completed. isReceivingStream set to false.");
            }, [remoteStream]); // Removed peerConnection from dependencies

            // WebRTC: Function to receive stream (create peer connection, answer)
            const receiveStream = React.useCallback(async (channelNameForStream, streamerId) => { // Added channelNameForStream
                console.log("DEBUG PROFUNDO: receiveStream - Initiated. Streamer ID:", streamerId, "Channel:", channelNameForStream);
                // Ensure auth and db are ready
                if (!db || !userId || !channelNameForStream || !streamerId) {
                    showMessage("Database or user information not ready. Cannot receive stream.", 'error');
                    console.warn("DEBUG PROFUNDO: receiveStream - DB, userId or streamerId not ready.");
                    return;
                }

                // Prevent multiple receive attempts
                if (isReceivingStream || isStartingStream || isStreaming) {
                    console.warn("DEBUG PROFUNDO: Already receiving or starting stream. Aborting receiveStream.");
                    return;
                }

                setIsReceivingStream(true);
                setIsLoading(true);
                console.log("DEBUG PROFUNDO: receiveStream - isReceivingStream set to true. isLoading set to true.");

                let pcInstance;

                try {
                    const servers = {
                        iceServers: [
                            {
                                urls: "stun:stun.l.google.com:19302" // Public STUN server for debugging
                            }
                        ]
                    };
                    console.log("DEBUG PROFUNDO: RTCPeerConnection initialized for receiving with ICE servers (DEBUG STUN ONLY):", servers);
                    pcInstance = new RTCPeerConnection(servers);
                    peerConnectionRef.current = pcInstance; // Assign to ref
                    console.log("DEBUG PROFUNDO: receiveStream - New PeerConnection created and set to ref. Current ref:", peerConnectionRef.current);
                    console.log(`DEBUG PROFUNDO: Immediately after PC creation (RECEIVER) - signalingState: ${peerConnectionRef.current.signalingState}, iceGatheringState: ${peerConnectionRef.current.iceGatheringState}`);

                    // Ensure peerConnectionRef.current is not null before setting event handlers
                    if (!peerConnectionRef.current) {
                        console.error("DEBUG PROFUNDO: PeerConnection is null after creation in receiveStream. Aborting.");
                        showMessage("Error interno: PeerConnection no disponible.", 'error');
                        setIsReceivingStream(false);
                        setIsLoading(false);
                        return;
                    }

                    peerConnectionRef.current.onicegatheringstatechange = () => {
                        console.log(`DEBUG PROFUNDO: PeerConnection iceGatheringState changed to: ${peerConnectionRef.current.iceGatheringState}`);
                    };
                    // NEW: Log connection state changes for debugging
                    peerConnectionRef.current.onconnectionstatechange = () => {
                        console.log(`DEBUG PROFUNDO: RTCPeerConnection state (viewer): ${peerConnectionRef.current.connectionState}`);
                        if (peerConnectionRef.current.connectionState === 'disconnected' || peerConnectionRef.current.connectionState === 'failed' || peerConnectionRef.current.connectionState === 'closed') {
                            console.log("DEBUG PROFUNDO: PeerConnection disconnected/failed/closed (viewer). Stopping receiving stream.");
                            showMessage("Stream desconectado debido a un error de conexión.", 'error');
                            setTimeout(() => stopReceivingStream(), 500);
                            // Removed unsubscribeOffer and streamerCandidatesListener from here, as they are handled in the return cleanup
                        }
                    };

                    peerConnectionRef.current.ontrack = (event) => {
                        console.log("DEBUG PROFUNDO: Remote track received for viewer:", event.streams[0]);
                        console.log(`DEBUG PROFUNDO: Remote stream active: ${event.streams[0].active}, tracks: ${event.streams[0].getTracks().length}`);
                        // NEW: Log details of remote video track if available
                        const videoTracks = event.streams[0].getVideoTracks();
                        if (videoTracks.length > 0) {
                            const videoTrack = videoTracks[0];
                            console.log(`DEBUG PROFUNDO: Remote video track state: ${videoTrack.readyState}, enabled: ${videoTrack.enabled}, muted: ${videoTrack.muted}`);
                            if (videoTrack.getSettings()) {
                                console.log(`DEBUG PROFUNDO: Remote video track settings: Width: ${videoTrack.getSettings().width}, Height: ${videoTrack.getSettings().height}, FrameRate: ${videoTrack.getSettings().frameRate}`);
                            }
                        }
                        setRemoteStream(event.streams[0]); // Update state with the remote stream
                    };

                    // Normalize activeChannel for Firestore paths
                    const normalizedChannelName = channelNameForStream.toLowerCase(); // Use passed channel name
                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/webrtc_signaling`, 'webrtc_data');
                    const candidatesCollectionRef = window.collection(webrtcDocRef, 'candidates');

                    peerConnectionRef.current.onicecandidate = async (event) => {
                        if (event.candidate) {
                            console.log("DEBUG PROFUNDO: ICE Candidate found for viewer:", event.candidate);
                            // Save ICE candidate to Firestore with senderId
                            try {
                                // Using addDoc instead of setDoc with a generated ID
                                await window.addDoc(candidatesCollectionRef, {
                                    ...event.candidate.toJSON(),
                                    senderId: userId // Add senderId to the candidate document
                                });
                                console.log("DEBUG PROFUNDO: ICE Candidate saved to Firestore for viewer:", event.candidate.toJSON());
                            } catch (e) {
                                console.error("DEBUG PROFUNDO: Error saving ICE candidate to Firestore (viewer):", e);
                                showMessage("Error al guardar candidato ICE.", 'error');
                            }
                        } else {
                            console.log("DEBUG PROFUNDO: All ICE candidates gathered for viewer.");
                        }
                    };

                    // Listen for the offer from the streamer
                    const unsubscribeOffer = window.onSnapshot(webrtcDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            // Check if offer exists, it's from the expected streamer, and remote description hasn't been set yet
                            if (data.offer && data.offer.senderId === streamerId && peerConnectionRef.current && !peerConnectionRef.current.currentRemoteDescription) {
                                const offer = new RTCSessionDescription(data.offer);
                                console.log("DEBUG PROFUNDO: Received offer from Firestore for viewer:", offer);
                                console.log("DEBUG PROFUNDO: Viewer's Remote Description (Received Offer) SDP:", offer.sdp); // <-- ADDED LOG
                                console.log(`DEBUG PROFUNDO: Viewer PC signalingState BEFORE setRemoteDescription(offer): ${peerConnectionRef.current.signalingState}`);
                                try {
                                    await peerConnectionRef.current.setRemoteDescription(offer);
                                    console.log("DEBUG PROFUNDO: Remote description (offer) set for viewer.");
                                    console.log(`DEBUG PROFUNDO: Viewer PC signalingState AFTER setRemoteDescription(offer): ${peerConnectionRef.current.signalingState}`);

                                    // Create and set answer
                                    const answer = await peerConnectionRef.current.createAnswer();
                                    console.log("DEBUG PROFUNDO: Answer created for viewer:", answer);
                                    console.log(`DEBUG PROFUNDO: Viewer PC signalingState BEFORE setLocalDescription(answer): ${peerConnectionRef.current.signalingState}`);
                                    await peerConnectionRef.current.setLocalDescription(answer);
                                    console.log("DEBUG PROFUNDO: Local description (answer) set for viewer. Local description object:", peerConnectionRef.current.localDescription);
                                    console.log("DEBUG PROFUNDO: Viewer's Local Description (Answer) SDP:", peerConnectionRef.current.localDescription.sdp); // <-- ADDED LOG
                                    console.log(`DEBUG PROFUNDO: Viewer PC signalingState AFTER setLocalDescription(answer): ${peerConnectionRef.current.signalingState}`);


                                    // Save answer to Firestore
                                    await window.setDoc(webrtcDocRef, {
                                        answer: {
                                            sdp: peerConnectionRef.current.localDescription.sdp,
                                            type: peerConnectionRef.current.localDescription.type,
                                            receiverId: userId, // Receiver ID is current user
                                            receiverUserName: userName,
                                            timestamp: window.serverTimestamp()
                                        }
                                    }, { merge: true });
                                    console.log("DEBUG PROFUNDO: WebRTC answer saved to Firestore for viewer:", peerConnectionRef.current.localDescription.toJSON());

                                    // After setting the answer, collect and add ICE candidates from streamer
                                    const candidateSnapshot = await window.getDocs(candidatesCollectionRef);
                                    candidateSnapshot.forEach(async (candidateDoc) => {
                                        // Only add candidates sent by the streamer (not by the viewer itself)
                                        if (candidateDoc.exists() && candidateDoc.data().senderId === streamerId && peerConnectionRef.current) {
                                            try {
                                                const candidate = new RTCIceCandidate(candidateDoc.data());
                                                await peerConnectionRef.current.addIceCandidate(candidate);
                                                console.log("DEBUG PROFUNDO: Added streamer ICE candidate for viewer:", candidate);
                                                // Optionally delete the candidate from Firestore after adding it to avoid processing duplicates
                                                await window.deleteDoc(window.doc(candidatesCollectionRef, candidateDoc.id));
                                            } catch (e) {
                                                console.error("DEBUG PROFUNDO: Error adding streamer ICE candidate for viewer (from snapshot):", e);
                                            }
                                        }
                                    });
                                    showMessage("Recibiendo stream!", 'success');
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error setting remote/local description or saving answer (viewer):", e);
                                    showMessage("Error al procesar oferta/respuesta del stream.", 'error');
                                }
                            }
                        }
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error listening for offer for viewer:", error);
                        showMessage("Error al escuchar la oferta del stream.", 'error');
                    });

                    // Listen for candidates from streamer (after offer is set)
                    const streamerCandidatesListener = window.onSnapshot(candidatesCollectionRef, (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === "added") {
                                const candidateData = change.doc.data();
                                // Only add candidates sent by the streamer (not by the viewer itself)
                                if (candidateData.senderId === streamerId && peerConnectionRef.current) {
                                    try {
                                        const candidate = new RTCIceCandidate(candidateData);
                                        if (peerConnectionRef.current.remoteDescription) { // Only add if remote description is set
                                            await peerConnectionRef.current.addIceCandidate(candidate);
                                            console.log("DEBUG PROFUNDO: Added streamer candidate (via listener) for viewer:", candidate);
                                            // Optionally delete the candidate from Firestore after adding it to avoid processing duplicates
                                            await window.deleteDoc(window.doc(candidatesCollectionRef, change.doc.id));
                                        } else {
                                            console.warn("DEBUG PROFUNDO: Remote description not set yet, deferring streamer candidate for viewer:", candidate);
                                        }
                                    } catch (e) {
                                        console.error("DEBUG PROFUNDO: Error adding streamer candidate (via listener) for viewer:", e);
                                    }
                                }
                            }
                        });
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error listening for streamer candidates for viewer:", error);
                        showMessage("Error al escuchar candidatos del stream.", 'error');
                    });

                    return () => {
                        unsubscribeOffer();
                        streamerCandidatesListener(); // Unsubscribe candidates listener
                    };

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error receiving stream:", error);
                    showMessage("Error al recibir el stream: " + error.message, 'error');
                    if (peerConnectionRef.current) { // Use ref
                        peerConnectionRef.current.close();
                        peerConnectionRef.current = null; // Clear ref
                    }
                    setRemoteStream(null);
                    setIsReceivingStream(false);
                } finally {
                    setIsLoading(false);
                    console.log("DEBUG PROFUNDO: receiveStream - Finally block executed. isLoading set to false.");
                }
            }, [db, userId, userName, showMessage, isReceivingStream, isStartingStream, isStreaming]);


            // WebRTC: Function to stop streaming
            const stopStreaming = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: stopStreaming - Initiated.");
                setIsLoading(true);
                try {
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        setLocalStream(null);
                        console.log("DEBUG PROFUNDO: Local stream tracks stopped and cleared.");
                    }
                    if (remoteStream) { // NEW: Ensure remote stream is also stopped and cleared
                        remoteStream.getTracks().forEach(track => track.stop());
                        setRemoteStream(null);
                        if (remoteVideoRef.current) {
                            remoteVideoRef.current.srcObject = null;
                            remoteVideoRef.current.muted = true; // Ensure it's muted
                            remoteVideoRef.current.load(); // Reload to clear previous frame
                        }
                        console.log("DEBUG PROFUNDO: Remote stream tracks stopped and cleared (during stopStreaming).");
                    }
                    if (peerConnectionRef.current) { // Use ref
                        peerConnectionRef.current.close();
                        peerConnectionRef.current = null; // Clear ref
                        console.log("DEBUG PROFUNDO: PeerConnection closed.");
                    }

                    // Update channel status in Firestore to indicate not streaming
                    if (activeChannel && db && userId && isStreamer) {
                        const normalizedActiveChannel = activeChannel.name.toLowerCase();
                        const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                        await window.setDoc(channelDocRef, {
                            isStreaming: false,
                            streamerId: null,
                            streamerUserName: null,
                            lastActivity: window.serverTimestamp()
                        }, { merge: true });
                        console.log("DEBUG PROFUNDO: Channel status updated in Firestore: isStreaming=false.");

                        // Clear WebRTC signaling data for this channel
                        const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc_signaling`, 'webrtc_data');
                        const webrtcDocSnap = await window.getDoc(webrtcDocRef);
                        if (webrtcDocSnap.exists()) {
                            // Delete candidates subcollection first
                            const candidatesColRef = window.collection(webrtcDocRef, 'candidates');
                            const candidatesSnapshot = await window.getDocs(candidatesColRef);
                            const deleteCandidatePromises = [];
                            candidatesSnapshot.forEach(candidateDoc => {
                                deleteCandidatePromises.push(window.deleteDoc(window.doc(candidatesColRef, candidateDoc.id)));
                            });
                            console.log(`DEBUG PROFUNDO: stopStreaming - Deleting ${deleteCandidatePromises.length} WebRTC candidates.`);
                            await Promise.all(deleteCandidatePromises);

                            // Then delete the webrtc_data document itself
                            await window.deleteDoc(webrtcDocRef);
                            console.log("DEBUG PROFUNDO: stopStreaming - WebRTC signaling data cleared from Firestore.");
                        }
                    }

                    setIsStreaming(false);
                    setIsStreamer(false);
                    showMessage("Stream detenido correctamente.", 'info');
                    console.log("DEBUG PROFUNDO: Stream stopped successfully.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error stopping stream:", error);
                    showMessage("Error al detener el stream: " + error.message, 'error');
                } finally {
                    setIsLoading(false);
                    console.log("DEBUG PROFUNDO: stopStreaming - Finally block executed.");
                }
            }, [localStream, remoteStream, activeChannel, db, userId, isStreamer, showMessage]);

            // NEW: WebRTC: Function to start streaming (get camera/mic, create peer connection, offer)
            // Version: 2025-07-21-DailyFix-v90
            const startStreaming = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: startStreaming - Initiated. Version: 2025-07-21-DailyFix-v90 (WebRTC Streaming - AbortError Fix)");

                // Get the current user ID directly from Firebase Auth right before using it
                const currentAuthUser = auth.currentUser; // Use auth from state
                const currentAuthUserId = currentAuthUser ? currentAuthUser.uid : null;

                // Ensure auth and db are ready and currentAuthUserId is set
                if (!db || !currentAuthUserId || !activeChannel || !userName) {
                    showMessage("Database or user information not ready. Cannot start stream.", 'error');
                    console.warn("DEBUG PROFUNDO: startStreaming - DB, userId or userName not ready.");
                    return;
                }

                // Prevent multiple stream attempts
                if (isStartingStream || isStreaming || isReceivingStream) {
                    console.warn("DEBUG PROFUNDO: Stream already active or in process of starting. Aborting startStreaming.");
                    showMessage("Ya hay un stream activo o en proceso de inicio.", 'info');
                    return;
                }

                setIsStartingStream(true); // Set flag to true at the beginning
                setIsLoading(true); // Show loading spinner
                console.log("DEBUG PROFUNDO: startStreaming - isStartingStream set to true. isLoading set to true.");

                let pcInstance; // Use a local variable for the PC instance
                let stream; // Declare stream here

                try {
                    // Request media permissions explicitly if not already granted (redundant but safe)
                    console.log("DEBUG PROFUNDO: Requesting media permissions explicitly...");
                    const mediaPermissionStatus = await navigator.permissions.query({ name: 'camera' });
                    const audioPermissionStatus = await navigator.permissions.query({ name: 'microphone' });

                    if (mediaPermissionStatus.state === 'granted' && audioPermissionStatus.state === 'granted') {
                        console.log("DEBUG PROFUNDO: Media permissions successfully granted.");
                    } else {
                        console.warn("DEBUG PROFUNDO: Media permissions not explicitly granted, getUserMedia will prompt.");
                    }

                    // Get local media stream
                    console.log("DEBUG PROFUNDO: Attempting to get user media (video and audio).");
                    stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    console.log(`DEBUG PROFUNDO: Stream obtained from getUserMedia. Active: ${stream.active}, ReadyState: ${stream.readyState}, Tracks: ${stream.getTracks().length}`);

                    // NEW: Explicitly check if the stream is active right after getUserMedia
                    if (!stream.active) {
                        const errorMessage = "Media stream is not active after getUserMedia. Please check your camera/microphone and browser settings.";
                        console.error("DEBUG PROFUNDO: " + errorMessage);
                        showMessage(errorMessage, 'error');
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        setIsLoading(false);
                        setIsStartingStream(false);
                        return; // Exit early if stream is not active
                    }

                    setLocalStream(stream);
                    // Removed direct assignment here; relying solely on useEffect for localVideoRef.current


                    // WebRTC Peer Connection setup - TEMPORARILY USING ONLY PUBLIC STUN SERVER FOR DEBUGGING
                    const servers = {
                        iceServers: [
                            {
                                urls: "stun:stun.l.google.com:19302" // Public STUN server
                            }
                        ]
                    };
                    console.log("DEBUG PROFUNDO: RTCPeerConnection initialized with ICE servers (DEBUG STUN ONLY):", servers);
                    pcInstance = new RTCPeerConnection(servers); // Assign to local variable
                    peerConnectionRef.current = pcInstance; // Assign to ref
                    console.log("DEBUG PROFUNDO: startStreaming - New PeerConnection created and set to ref. Current ref:", peerConnectionRef.current);
                    console.log(`DEBUG PROFUNDO: Immediately after PC creation (STREAMER) - signalingState: ${peerConnectionRef.current.signalingState}, iceGatheringState: ${peerConnectionRef.current.iceGatheringState}`);

                    // Ensure peerConnectionRef.current is not null before setting event handlers
                    if (!peerConnectionRef.current) {
                        console.error("DEBUG PROFUNDO: PeerConnection is null after creation in startStreaming. Aborting.");
                        showMessage("Error interno: PeerConnection no disponible.", 'error');
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        setIsLoading(false);
                        setIsStartingStream(false);
                        return;
                    }


                    // Add onnegotiationneeded listener (for debugging, not primary trigger)
                    peerConnectionRef.current.onnegotiationneeded = () => {
                        console.log("DEBUG PROFUNDO: PeerConnection onnegotiationneeded event fired.");
                    };

                    // Add onicegatheringstatechange listener immediately after PC creation
                    peerConnectionRef.current.onicegatheringstatechange = () => {
                        console.log(`DEBUG PROFUNDO: PeerConnection iceGatheringState changed to: ${peerConnectionRef.current.iceGatheringState}`);
                    };
                    // NEW: Log connection state changes for debugging
                    peerConnectionRef.current.onconnectionstatechange = () => {
                        console.log(`DEBUG PROFUNDO: RTCPeerConnection state (streamer): ${peerConnectionRef.current.connectionState}`);
                        if (peerConnectionRef.current.connectionState === 'disconnected' || peerConnectionRef.current.connectionState === 'failed' || peerConnectionRef.current.connectionState === 'closed') {
                            console.log("DEBUG PROFUNDO: PeerConnection disconnected/failed/closed (streamer). Stopping stream.");
                            showMessage("Stream desconectado debido a un error de conexión.", 'error');
                            setTimeout(() => stopStreaming(), 500);
                            // Removed unsubscribeAnswer and channelCandidatesListener from here, as they are handled in the return cleanup
                        }
                    };

                    // Add local stream tracks to the peer connection
                    stream.getTracks().forEach(track => {
                        peerConnectionRef.current.addTrack(track, stream);
                        console.log("DEBUG PROFUNDO: Added local track to peer connection:", track.kind);
                        // NEW: Log details of local video track if available
                        if (track.kind === 'video') {
                            console.log(`DEBUG PROFUNDO: Local video track state: ${track.readyState}, enabled: ${track.enabled}, muted: ${track.muted}`);
                            if (track.getSettings()) {
                                console.log(`DEBUG PROFUNDO: Local video track settings: Width: ${track.getSettings().width}, Height: ${track.getSettings().height}, FrameRate: ${track.getSettings().frameRate}`);
                            }
                        }
                    });

                    // NEW: Small delay after adding tracks to allow PC to register them fully
                    console.log("DEBUG PROFUNDO: Adding small delay after adding tracks...");
                    await new Promise(resolve => setTimeout(resolve, 200)); // 200ms delay

                    // Normalize activeChannel for Firestore paths
                    const normalizedActiveChannel = activeChannel.name.toLowerCase(); // Use activeChannel.name

                    // Get reference to the 'webrtc_data' document
                    // FIX: Changed path to include 'webrtc_signaling' collection before 'webrtc_data' document
                    const webrtcDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc_signaling`, 'webrtc_data');
                    // Get reference to the 'candidates' subcollection under 'webrtc_data' document
                    const candidatesCollectionRef = window.collection(webrtcDocRef, 'candidates');


                    // Handle ICE candidates - NOW SAVING TO UNIFIED CANDIDATES COLLECTION
                    peerConnectionRef.current.onicecandidate = async (event) => {
                        if (event.candidate) {
                            console.log("DEBUG PROFUNDO: ICE Candidate found:", event.candidate);
                            // Save ICE candidate to Firestore with senderId
                            try {
                                // Using addDoc instead of setDoc with a generated ID
                                await window.addDoc(candidatesCollectionRef, {
                                    ...event.candidate.toJSON(),
                                    senderId: currentAuthUserId // Add senderId to the candidate document
                                });
                                console.log("DEBUG PROFUNDO: ICE Candidate saved to Firestore:", event.candidate.toJSON());
                            } catch (e) {
                                console.error("DEBUG PROFUNDO: Error saving ICE candidate to Firestore (streamer):", e);
                                showMessage("Error al guardar candidato ICE.", 'error');
                            }
                        } else {
                            console.log("DEBUG PROFUNDO: All ICE candidates gathered.");
                        }
                    };

                    // Handle remote stream when it arrives
                    peerConnectionRef.current.ontrack = (event) => {
                        console.log("DEBUG PROFUNDO: Remote track received:", event.streams[0]);
                        setRemoteStream(event.streams[0]);
                        // No direct assignment here; relying solely on useEffect for remoteVideoRef.current
                    };

                    // NEW: Explicitly create and set offer after adding tracks with a timeout
                    console.log("DEBUG PROFUNDO: BEFORE createOffer. Current signalingState:", peerConnectionRef.current.signalingState);
                    console.log("DEBUG PROFUNDO: Transceivers:", peerConnectionRef.current.getTransceivers());
                    console.log(`DEBUG PROFUNDO: Media Stream State - active: ${stream.active}, readyState: ${stream.readyState}, Tracks: ${stream.getTracks().length}`);

                    // NEW: Robust check for stream and track readiness before creating offer - PRIORITIZING TRACK READYSTATE
                    let offer;
                    const maxReadinessRetries = 20; // Increased retries
                    const readinessRetryDelayMs = 100; // Shorter delay for readiness checks

                    for (let i = 0; i < maxReadinessRetries; i++) {
                        console.log(`DEBUG PROFUNDO: Checking stream readiness (Attempt ${i + 1}/${maxReadinessRetries})...`);

                        // Check overall stream state (active and tracks count)
                        if (!stream.active || stream.getTracks().length === 0) {
                             const errorMessage = "Media stream is not active or has no tracks. Active: " + stream.active + ", Tracks: " + stream.getTracks().length + ".";
                             console.warn("DEBUG PROFUNDO: " + errorMessage);
                             if (i === maxReadinessRetries - 1) {
                                 showMessage(errorMessage + " Please check your camera/microphone.", 'error');
                                 throw new Error(errorMessage);
                             }
                             await new Promise(resolve => setTimeout(resolve, readinessRetryDelayMs));
                             continue;
                        }

                        // Check individual track readinessState - THIS IS THE PRIMARY CHECK NOW
                        const allTracksReady = stream.getTracks().every(track => {
                            console.log(`DEBUG PROFUNDO: Track ${track.kind} readyState: ${track.readyState}`);
                            return track.readyState === 'live';
                        });

                        if (allTracksReady) { // If all individual tracks are 'live', consider the stream ready
                            console.log("DEBUG PROFUNDO: All individual media tracks are ready.");
                            // Also log the stream's readyState for continued observation, even if it's undefined
                            console.log(`DEBUG PROFUNDO: Final Media Stream readyState (for info): ${stream.readyState}`);
                            break; // All ready, exit readiness loop
                        } else {
                            const errorMessage = "Not all media tracks are ready. Waiting for readyState 'live'.";
                            console.warn("DEBUG PROFUNDO: " + errorMessage);
                            if (i === maxReadinessRetries - 1) {
                                showMessage(errorMessage + " Please ensure your camera/microphone are fully initialized.", 'error');
                                throw new Error(errorMessage);
                            }
                            await new Promise(resolve => setTimeout(resolve, readinessRetryDelayMs));
                        }
                    }

                    // NEW: Check PeerConnection signalingState before creating offer
                    if (!peerConnectionRef.current || peerConnectionRef.current.signalingState === 'closed') { // Added peerConnectionRef.current check
                        const errorMessage = "PeerConnection is closed or null. Cannot create offer.";
                        console.error("DEBUG PROFUNDO: " + errorMessage);
                        showMessage(errorMessage, 'error');
                        return; // Exit here
                    }

                    // Now attempt to create offer after readiness check
                    const createOfferPromise = peerConnectionRef.current.createOffer(); // Removed offerOptions as it's not defined
                    const createOfferTimeout = new Promise((resolve, reject) =>
                        setTimeout(() => reject(new Error('createOffer timed out')), 20000) // 20 seconds timeout for createOffer
                    );

                    try {
                        console.log("DEBUG PROFUNDO: Attempting to create offer (with timeout). Awaiting Promise.race.");
                        offer = await Promise.race([createOfferPromise, createOfferTimeout]);
                        console.log("DEBUG PROFUNDO: AFTER createOffer. Offer created:", offer);
                    } catch (createOfferError) {
                        console.error(`DEBUG PROFUNDO: Error creating offer (WebRTC): Name: ${createOfferError.name}, Message: ${createOfferError.message}`, createOfferError);
                        showMessage(`Error al iniciar stream (WebRTC Offer): ${createOfferError.message}. Por favor, verifica los permisos de cámara/micrófono.`, 'error');
                        // Clean up WebRTC resources on error
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        if (peerConnectionRef.current) { // Use ref
                            peerConnectionRef.current.close();
                            peerConnectionRef.current = null; // Clear ref
                        }
                        setLocalStream(null);
                        setIsStreaming(false);
                        setIsStreamer(false);
                        setIsLoading(false);
                        setIsStartingStream(false);
                        return; // Exit if offer creation fails
                    }


                    // Specific try-catch for setLocalDescription with a timeout
                    const setLocalDescriptionPromise = peerConnectionRef.current.setLocalDescription(offer);
                    const setLocalDescriptionTimeout = new Promise((resolve, reject) =>
                        setTimeout(() => reject(new Error('setLocalDescription timed out')), 15000) // 15 seconds timeout
                    );

                    try {
                        console.log("DEBUG PROFUNDO: Attempting to set local description (with timeout). Awaiting Promise.race.");
                        await Promise.race([setLocalDescriptionPromise, setLocalDescriptionTimeout]);
                        console.log("DEBUG PROFUNDO: Offer set as local description. Local description object:", peerConnectionRef.current.localDescription);
                        console.log(`DEBUG PROFUNDO: PeerConnection state AFTER setLocalDescription - signalingState: ${peerConnectionRef.current.signalingState}, iceGatheringState: ${peerConnectionRef.current.iceGatheringState}`);
                        showMessage("Local description set successfully!", 'success');

                        // Save offer to Firestore as a field in 'webrtc_data' document
                        await window.setDoc(webrtcDocRef, {
                            offer: {
                                sdp: peerConnectionRef.current.localDescription.sdp,
                                type: peerConnectionRef.current.localDescription.type,
                                senderId: currentAuthUserId,
                                senderUserName: userName,
                                timestamp: window.serverTimestamp()
                            }
                        }, { merge: true });
                        console.log("DEBUG PROFUNDO: WebRTC offer saved to Firestore as field in webrtc_data:", peerConnectionRef.current.localDescription.toJSON());

                        // Update channel status in Firestore to indicate streaming
                        const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                        await window.setDoc(channelDocRef, {
                            isStreaming: true,
                            streamerId: currentAuthUserId,
                            streamerUserName: userName,
                            lastActivity: window.serverTimestamp()
                        }, { merge: true });
                        console.log("DEBUG PROFUNDO: Channel status updated in Firestore: isStreaming=true.");

                        setIsStreaming(true);
                        setIsStreamer(true); // Mark current user as streamer
                        showMessage("Stream iniciado correctamente!", 'success');
                        console.log("DEBUG PROFUNDO: Stream started successfully. isStreaming=true, isStreamer=true.");

                    } catch (setLocalDescError) {
                        console.error(`DEBUG PROFUNDO: Error al establecer la descripción local del stream (WebRTC): Nombre: ${setLocalDescError.name}, Mensaje: ${setLocalDescError.message}`, setLocalDescError);
                        showMessage(`Error al establecer la descripción local del stream: ${setLocalDescError.message}.`, 'error');
                        // Clean up WebRTC resources on error
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        if (peerConnectionRef.current) { // Use ref
                            peerConnectionRef.current.close();
                            peerConnectionRef.current = null; // Clear ref
                        }
                        setLocalStream(null);
                        setIsStreaming(false);
                        setIsStreamer(false);
                        setIsLoading(false);
                        setIsStartingStream(false);
                        return; // Exit if setLocalDescription fails
                    }

                    // Listen for answers from viewers
                    // The answer is now a field within the 'webrtc_data' document
                    const unsubscribeAnswer = window.onSnapshot(webrtcDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.answer && data.answer.receiverId === currentAuthUserId && peerConnectionRef.current && !peerConnectionRef.current.currentRemoteDescription) { // Added peerConnectionRef.current check
                                const answer = new RTCSessionDescription(data.answer);
                                console.log("DEBUG PROFUNDO: Received answer from Firestore:", answer);
                                console.log(`DEBUG PROFUNDO: Streamer PC signalingState BEFORE setRemoteDescription(answer): ${peerConnectionRef.current.signalingState}`);
                                try {
                                    await peerConnectionRef.current.setRemoteDescription(answer);
                                    console.log("DEBUG PROFUNDO: Remote description (answer) set.");
                                    console.log(`DEBUG PROFUNDO: Streamer PC signalingState AFTER setRemoteDescription(answer): ${peerConnectionRef.current.signalingState}`);
                                    showMessage("Respuesta de espectador recibida.", 'info');

                                    // After setting the answer, collect and add ICE candidates from viewer
                                    // NOW LISTENING TO THE UNIFIED CANDIDATES COLLECTION
                                    const candidateSnapshot = await window.getDocs(candidatesCollectionRef);
                                    candidateSnapshot.forEach(async (candidateDoc) => {
                                        if (candidateDoc.exists() && candidateDoc.data().senderId !== currentAuthUserId && peerConnectionRef.current) { // Added peerConnectionRef.current check
                                            try {
                                                const candidate = new RTCIceCandidate(candidateData);
                                                await peerConnectionRef.current.addIceCandidate(candidate);
                                                console.log("DEBUG PROFUNDO: Added viewer ICE candidate:", candidate);
                                                // Optionally delete the candidate from Firestore after adding it to avoid processing duplicates
                                                await window.deleteDoc(window.doc(candidatesCollectionRef, candidateDoc.id));
                                            } catch (e) {
                                                console.error("DEBUG PROFUNDO: Error adding viewer ICE candidate (from snapshot):", e);
                                            }
                                        }
                                    });
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error setting remote description (streamer, answer):", e);
                                    showMessage("Error al procesar respuesta del espectador.", 'error');
                                }
                            }
                        }
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error listening for answer:", error);
                        showMessage("Error al escuchar la respuesta del stream.", 'error');
                    });

                    // Listen for candidates from viewers (after answer is set) - NOW LISTENING TO UNIFIED CANDIDATES COLLECTION
                    const channelCandidatesListener = window.onSnapshot(candidatesCollectionRef, (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === "added") {
                                const candidateData = change.doc.data();
                                if (candidateData.senderId !== currentAuthUserId && peerConnectionRef.current) { // Added peerConnectionRef.current check
                                    try {
                                        const candidate = new RTCIceCandidate(candidateData);
                                        if (peerConnectionRef.current.remoteDescription) { // Only add if remote description is set
                                            await peerConnectionRef.current.addIceCandidate(candidate);
                                            console.log("DEBUG PROFUNDO: Added viewer candidate (via listener):", candidate);
                                            // Optionally delete the candidate from Firestore after adding it to avoid processing duplicates
                                            await window.deleteDoc(window.doc(candidatesCollectionRef, change.doc.id));
                                        } else {
                                            console.warn("DEBUG PROFUNDO: Remote description not set yet, deferring viewer candidate:", candidate);
                                        }
                                    } catch (e) {
                                        console.error("DEBUG PROFUNDO: Error adding viewer candidate (via listener):", e);
                                        }
                                    }
                                }
                            });
                        }, (error) => {
                            console.error("DEBUG PROFUNDO: Error listening for viewer candidates:", error);
                            showMessage("Error al escuchar candidatos del espectador.", 'error');
                        });

                        // Clean up listeners when component unmounts or stream stops
                        // Moved onconnectionstatechange listener definition to receiveStream and startStreaming
                        // to ensure it's set up immediately with the PC and cleaned up with the PC's lifecycle.
                        return () => {
                            unsubscribeAnswer();
                            channelCandidatesListener(); // Unsubscribe candidates listener
                        };

                    } catch (error) {
                        console.error("DEBUG PROFUNDO: Error starting stream:", error);
                        showMessage("Error al iniciar el stream: " + error.message, 'error');
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        if (peerConnectionRef.current) { // Use ref
                            peerConnectionRef.current.close();
                            peerConnectionRef.current = null; // Clear ref
                        }
                        setLocalStream(null);
                        setRemoteStream(null);
                        setIsStreaming(false);
                        setIsReceivingStream(false);
                        setIsStreamer(false);
                    } finally {
                        setIsStartingStream(false);
                        setIsLoading(false);
                        console.log("DEBUG PROFUNDO: startStreaming - Finally block executed. isStartingStream set to false. isLoading set to false.");
                    }
                }, [db, userId, userName, showMessage, isStartingStream, isStreaming, isReceivingStream, localStream, activeChannel, auth, stopStreaming]); // Added stopStreaming to dependencies

            // Effect to assign localStream to local video element
            React.useEffect(() => {
                console.log("DEBUG PROFUNDO: useEffect for localStream triggered. localStream:", localStream, "localVideoRef.current:", localVideoRef.current, "isStreamer:", isStreamer);
                // Only attempt to attach if localVideoRef.current is available and localStream exists, AND we are the streamer
                if (localVideoRef.current && localStream && isStreamer) {
                    localVideoRef.current.srcObject = localStream;
                    console.log("DEBUG PROFUNDO: Local video stream attached to video element via useEffect.");
                    // NEW: Play the local video when it's attached
                    localVideoRef.current.play().catch(e => console.error("DEBUG PROFUNDO: Error playing local video:", e));
                } else if (!localVideoRef.current && localStream && isStreamer) {
                    console.warn("DEBUG PROFUNDO: localVideoRef.current is null in useEffect for localStream, but localStream exists and isStreamer is true. This might indicate a rendering delay.");
                }
            }, [localStream, isStreamer]);

            // Effect to assign remoteStream to remote video element
            React.useEffect(() => {
                console.log("DEBUG PROFUNDO: useEffect for remoteStream triggered. remoteStream:", remoteStream, "remoteVideoRef.current:", remoteVideoRef.current, "isReceivingStream:", isReceivingStream);
                if (remoteVideoRef.current && remoteStream && isReceivingStream) {
                    // Only assign srcObject if it's different to prevent unnecessary reloads/interruptions
                    if (remoteVideoRef.current.srcObject !== remoteStream) {
                        console.log("DEBUG PROFUNDO: Assigning remote stream to video element via useEffect.");
                        remoteVideoRef.current.srcObject = remoteStream;

                        // Wait for 'loadedmetadata' before attempting to play
                        remoteVideoRef.current.onloadedmetadata = () => {
                            console.log("DEBUG PROFUNDO: Remote video loadedmetadata event fired (from useEffect).");
                            // Only attempt to play if the video is paused or if it hasn't started playing yet
                            if (remoteVideoRef.current.paused || remoteVideoRef.current.ended || remoteVideoRef.current.readyState === 0) {
                                console.log("DEBUG PROFUNDO: Attempting to play remote video (muted) after loadedmetadata (from useEffect).");
                                remoteVideoRef.current.muted = true; // Start muted for autoplay
                                remoteVideoRef.current.play().then(() => {
                                    console.log("DEBUG PROFUNDO: Remote video started playing (muted) from useEffect/loadedmetadata.");
                                    setIsLoading(false); // Hide loading spinner once video starts (even if muted)
                                    showMessage("Uniéndote al stream (silenciado). Por favor, haz clic para activar el audio.", 'info');
                                }).catch(error => {
                                    console.error(`DEBUG PROFUNDO: Error attempting to play remote video from useEffect/loadedmetadata: Name: ${error.name}, Message: ${error.message}`, error);
                                    showMessage("Error al reproducir el video del stream. Habilite la reproducción automática o haga clic para reproducir.", 'error');
                                    setIsLoading(false); // Hide loading spinner on error
                                });
                            } else {
                                console.log("DEBUG PROFUNDO: Remote video already playing or not in a state to be played automatically (from useEffect/loadedmetadata).");
                                setIsLoading(false);
                            }
                            remoteVideoRef.current.onloadedmetadata = null; // Remove the event listener after it fires once
                        };
                    } else {
                        console.log("DEBUG PROFUNDO: remoteVideoRef.current.srcObject is already the same stream (from useEffect).");
                        // If the stream is already set, and it's not playing, try to play it (e.g., if it was paused externally)
                        if (remoteVideoRef.current.paused || remoteVideoRef.current.ended || remoteVideoRef.current.readyState === 0) {
                             console.log("DEBUG PROFUNDO: Attempting to play existing remote video (muted) from useEffect.");
                             remoteVideoRef.current.muted = true;
                             remoteVideoRef.current.play().then(() => {
                                 console.log("DEBUG PROFUNDO: Existing remote video started playing (muted) from useEffect.");
                                 setIsLoading(false);
                                 showMessage("Uniéndote al stream (silenciado). Por favor, haz clic para activar el audio.", 'info');
                             }).catch(error => {
                                 console.error(`DEBUG PROFUNDO: Error playing existing remote video from useEffect: Name: ${error.name}, Message: ${error.message}`, error);
                                 showMessage("Error al reproducir el video del stream. Habilite la reproducción automática o haga clic para reproducir.", 'error');
                                 setIsLoading(false);
                             });
                        } else {
                            console.log("DEBUG PROFUNDO: Remote video already playing or not in a state to be played automatically (existing stream from useEffect).");
                            setIsLoading(false);
                        }
                    }
                } else if (!remoteVideoRef.current && remoteStream && isReceivingStream) {
                    console.warn("DEBUG PROFUNDO: remoteVideoRef.current is null in useEffect for remoteStream, but remoteStream exists and isReceivingStream is true. This might indicate a rendering delay.");
                }
            }, [remoteStream, isReceivingStream, showMessage]);


            const copyToClipboard = React.useCallback((text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showMessage(`"${text}" copied to clipboard!`, 'success');
                } catch (err) {
                    console.error('Error copying to clipboard:', err);
                    showMessage('Error copying to clipboard.', 'error');
                }
                document.body.removeChild(textarea);
            }, [showMessage]);

            const handleAttachFile = React.useCallback(() => {
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
                setShowOptionsMenu(false);
            }, []);


            const onFileSelected = React.useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                if (!isAuthReady || !db || !userId || !activeChannel) {
                    showMessage("Application not ready to upload files. Please try again.", 'error');
                    return;
                }

                setIsLoading(true);

                // --- Cloudinary Configuration (REPLACE THESE WITH YOURS) ---
                const cloudName = 'dq527zvti'; // Your Cloudinary Cloud name
                const unsignedUploadPreset = 'jlchannel'; // The unsigned upload preset you created in Cloudinary
                // -------------------------------------------------------------

                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', unsignedUploadPreset);

                try {
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/auto/upload`, {
                        method: 'POST',
                        body: formData,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error uploading file to Cloudinary:", errorData);
                        showMessage(`Error uploading file: ${errorData.error.message || 'Unknown error'}`, 'error');
                        return;
                    }

                    const data = await response.json();
                    const downloadURL = data.secure_url;
                    console.log('File available on Cloudinary:', downloadURL);

                    const normalizedActiveChannel = activeChannel.name.toLowerCase(); // Use activeChannel.name
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    await window.addDoc(messagesColRef, {
                        text: downloadURL,
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                        fileUrl: downloadURL,
                        fileName: file.name,
                        fileType: file.type,
                    });

                    setCurrentMessage('');
                    showMessage('File successfully uploaded and sent to chat.', 'success');
                    scrollToBottom();

                } catch (error) {
                    console.error("Error in Cloudinary upload (general catch):", error);
                    showMessage(`Error initiating upload: ${error.message || 'Unknown error'}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [activeChannel, isAuthReady, db, userId, userName, showMessage, setIsLoading, scrollToBottom]);


            // PWA: Handler for the install button
            const handleInstallClick = React.useCallback(async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    setDeferredPrompt(null);
                }
            }, [deferredPrompt]);

            const renderHomePage = () => (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-600 to-blue-500 p-4 font-inter">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">CHANNEL</h1>

                        {deferredPrompt && !isPwaInstalled && (
                            <button
                                onClick={handleInstallClick}
                                className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-3"
                            >
                                Install App
                            </button>
                        )}

                        <div className="mb-6">
                            <label htmlFor="username-input" className="block text-gray-700 text-sm font-bold mb-2">
                                Your Username:
                            </label>
                            <div className="flex gap-2">
                                <input
                                    id="username-input"
                                    type="text"
                                    placeholder="Username"
                                    className="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-lg"
                                    value={userName}
                                    onChange={(e) => {
                                        setUserName(e.target.value);
                                        // When username changes, reset confirmation and Tigre related states
                                        setUserNameConfirmed(false);
                                        setIsTigre(false);
                                        setShowTigreCodeInput(false);
                                        setTigreCode('');
                                    }}
                                    maxLength="48"
                                    disabled={userNameConfirmed}
                                />
                                {!userNameConfirmed && (
                                    <button
                                        onClick={handleConfirmUserName}
                                        className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Confirm
                                    </button>
                                )}
                                {userNameConfirmed && (
                                    <button
                                        onClick={() => {
                                            setUserNameConfirmed(false);
                                            setIsTigre(false);
                                            setShowTigreCodeInput(false);
                                            setTigreCode('');
                                            if (db && userId) {
                                                const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                                                window.setDoc(userProfileRef, { isTigreActive: false }, { merge: true }).catch(e => console.error("Error deactivating Tigre in Firestore:", e));
                                            }
                                        }}
                                        className="bg-gray-400 hover:bg-400 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Edit
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* NEW LOGIC: showTigreCodeInput is now controlled by handleConfirmUserName */}
                        {userNameConfirmed && userName.trim() === 'Julian360' && showTigreCodeInput && !isTigre && (
                            <div className="mt-6 p-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-lg">
                                <p className="mb-2 font-semibold">Tigre Mode: Enter the 8-digit code to enable.</p>
                                <input
                                    type="password"
                                    placeholder="8-digit code"
                                    className="w-full p-3 border border-yellow-400 rounded-lg focus:outline-none focus:ring-2 focus:focus:ring-yellow-500"
                                    value={tigreCode}
                                    onChange={(e) => setTigreCode(e.target.value)}
                                    maxLength="8"
                                />
                                <button
                                    onClick={handleTigreCodeSubmit}
                                    className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                >
                                    Confirm Code
                                </button>
                            </div>
                        )}
                        {isTigre && (
                            <div className="mt-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg">
                                <p className="font-semibold">Tigre Mode Activated!</p>
                            </div>
                        )}

                        <div className="mb-6">
                            <input
                                id="channel-name-input"
                                ref={channelInputRef}
                                type="text"
                                placeholder="Channel name"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg"
                                value={channelName}
                                onChange={(e) => setChannelName(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleCreateChannel();
                                    }
                                }}
                                maxLength="128"
                                disabled={!userNameConfirmed}
                            />
                        </div>

                        <button
                            onClick={handleCreateChannel}
                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-4"
                            disabled={!userNameConfirmed}
                        >
                            Enter
                        </button>

                        <button
                            onClick={() => setCurrentPage('explore')}
                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl"
                            disabled={!userNameConfirmed}
                        >
                            Explore Channels
                        </button>

                        {/* NEW: Button to request media permissions */}
                        <button
                            onClick={requestMediaPermissions}
                            className="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mt-4"
                        >
                            Check & Request Media Permissions
                        </button>
                    </div>
                </div>
            );

            const renderChannelPage = () => (
                <div className="relative flex flex-col items-center min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 font-inter">
                    <div className="h-full bg-white p-4 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-6 mb-2 pb-1 relative">
                        <h1
                            className="text-4xl font-extrabold text-gray-800 mb-2 cursor-pointer"
                            onClick={() => copyToClipboard(activeChannel.name)}
                        >
                            Channel: <span className="text-blue-600">{activeChannel.name}</span> {/* Use activeChannel.name */}
                        </h1>
                        <p className="text-lg text-gray-600 mb-2">User: <span className="font-bold text-purple-600">{userName}</span></p>

                        <div className="absolute top-4 right-4" ref={optionsMenuRef}>
                            <button
                                onClick={() => setShowOptionsMenu(!showOptionsMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Channel options"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showOptionsMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    {isStreamer ? (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { stopStreaming(); setShowOptionsMenu(false); }}>Stop Stream ⏹️</button>
                                    ) : (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { startStreaming(); setShowOptionsMenu(false); }}>Stream 🎥</button>
                                    )}
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={handleAttachFile}>Attach File 📎</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setShowActivityPanel(true); setShowOptionsMenu(false); }}>Activity 👥</button>
                                </div>
                            )}
                        </div>

                        {/* Video container for streaming */}
                        {(isStreaming || isReceivingStream) && (
                            <div className="relative w-full aspect-video bg-black rounded-lg mb-4 overflow-hidden">
                                {isStreamer && localStream && (
                                    <video
                                        ref={localVideoRef}
                                        autoPlay
                                        muted
                                        playsInline // ADDED: playsInline for iOS
                                        className="absolute inset-0 w-full h-full object-contain"
                                        style={{ transform: 'scaleX(-1)' }} // Mirror local video
                                    ></video>
                                )}
                                {!isStreamer && remoteStream && (
                                    <video
                                        ref={remoteVideoRef}
                                        autoPlay
                                        muted // NEW: Mute remote video to bypass autoplay policies
                                        playsInline // ADDED: playsInline for iOS
                                        className="absolute inset-0 w-full h-full object-contain"
                                    ></video>
                                )}
                                {(!localStream && !remoteStream) && (
                                    <div className="absolute inset-0 flex items-center justify-center text-white text-xl">
                                        Waiting for stream...
                                    </div>
                                )}
                                {/* NEW: Play button for viewer if remoteStream exists and is not playing */}
                                {/* Condition ensures button is visible if stream is received but not playing/muted */}
                                {!isStreamer && remoteStream && remoteVideoRef.current && (remoteVideoRef.current.paused || remoteVideoRef.current.muted) && (
                                    <button
                                        onClick={() => {
                                            if (remoteVideoRef.current) {
                                                remoteVideoRef.current.muted = false; // Unmute the HTML video element
                                                remoteVideoRef.current.play().catch(error => {
                                                    console.error("DEBUG PROFUNDO: Error al intentar reproducir video remoto desde el botón de desmutear:", error);
                                                    showMessage("Error al reproducir el video. Verifique los permisos de reproducción automática.", 'error');
                                                });
                                                if (remoteStream && remoteStream.getAudioTracks().length > 0) {
                                                    remoteStream.getAudioTracks().forEach(track => {
                                                        track.enabled = true; // Enable audio track
                                                    });
                                                }
                                                showMessage("Video desmuteado.", 'info');
                                            }
                                        }}
                                        className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white text-xl font-bold rounded-lg cursor-pointer hover:bg-opacity-75 transition-opacity duration-200"
                                    >
                                        ▶️ Play Stream
                                    </button>
                                )}
                            </div>
                        )}

                        <div className="mb-1 w-full bg-gray-100 p-1 rounded-xl shadow-inner border border-gray-200">
                            <div className="h-[70vh] md:h-[66vh] bg-white rounded-lg p-2 overflow-y-auto border border-gray-300 mb-1 flex flex-col" style={{ minHeight: '100px' }}>
                                {chatMessages.length > 0 ? (
                                    chatMessages.map((msg) => (
                                        <div key={msg.id} className={`mb-2 p-2 rounded-lg ${msg.senderId === userId ? 'bg-blue-100 self-end text-right' : 'bg-gray-200 self-start text-left'}`} style={{ maxWidth: '80%' }}>
                                            <p className="font-semibold text-xs">{msg.senderId === userId ? 'You' : msg.senderUserName}</p>
                                            {msg.fileUrl ? (
                                                msg.fileType && msg.fileType.startsWith('image/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block">
                                                        <img src={msg.fileUrl} alt={msg.fileName || 'Attached image'} className="max-w-xs max-h-32 rounded-lg object-contain mb-1" />
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🖼️ {msg.fileName || 'Attached Image'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('audio/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block w-full max-w-sm">
                                                        <audio controls src={msg.fileUrl} className="w-full mb-1"></audio>
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🎵 {msg.fileName || 'Attached Audio'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('video/') ? (
                                                    <div className="flex flex-col items-start">
                                                        <p className="text-sm md:text-base text-gray-800 mb-1">
                                                            ▶️ <strong>Video</strong>
                                                        </p>
                                                        <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                            {msg.fileName || 'Attached Video'}
                                                        </a>
                                                    </div>
                                                ) : (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                        📎 {msg.fileName || 'Attached File'}
                                                    </a>
                                                )
                                            ) : (
                                                <p className="text-sm md:text-base text-gray-800">{msg.text}</p>
                                            )}
                                            <p className="text-xs text-gray-500 mt-1">
                                                {msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Sending...'}
                                            </p>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-500 italic m-auto">Be the first to send a message.</p>
                                )}
                                <div ref={chatMessagesEndRef} />
                            </div>
                            <input
                                type="text"
                                placeholder="Write your message..."
                                className="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:focus:ring-blue-500"
                                value={currentMessage}
                                onChange={(e) => setCurrentMessage(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleSendMessage();
                                    }
                                }}
                                disabled={!isAuthReady || !db || !userId}
                            />
                            <input
                                type="file"
                                id="file-upload-input"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                onChange={onFileSelected}
                            />
                        </div>
                    </div>

                    {showActivityPanel && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-end z-40">
                            <div className="bg-white w-full max-w-xs p-6 rounded-l-2xl shadow-lg flex flex-col">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800">Channel Activity</h2>
                                    <button
                                        onClick={() => setShowActivityPanel(false)}
                                        className="text-gray-500 hover:text-gray-700 text-3xl font-bold"
                                    >
                                        &times;
                                    </button>
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 mb-3">Channel Members:</h3>
                                <div className="flex-grow overflow-y-auto">
                                    {channelMembers.length > 0 ? (
                                        <ul className="space-y-2">
                                            {channelMembers.map((member) => (
                                                <li key={member.id} className="flex items-center text-gray-700">
                                                    <span className="font-medium">{member.userName}</span>
                                                </li>
                                            ))}
                                        </ul>
                                    ) : (
                                        <p className="text-gray-500 italic">No members registered yet.</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );

            const renderExplorePage = () => (
                <div className="flex flex-col items-center justify-start min-h-screen bg-gradient-to-br from-teal-500 to-cyan-600 p-4 font-inter">
                    <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-8 relative">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">Explore Channels</h1>
                        <p className="text-lg text-gray-600 mb-8"> </p>

                        <div className="absolute top-4 right-4" ref={exploreMenuRef}>
                            <button
                                onClick={() => setShowExploreMenu(!showExploreMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Explore options"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showExploreMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('activity'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Most Active
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('recent'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Most Recent
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => {
                                            setShowSearchInput(!showSearchInput);
                                            setShowExploreMenu(false);
                                            setSortOption('none');
                                        }}
                                    >
                                        Search Channel
                                    </button>
                                </div>
                            )}
                        </div>

                        {showSearchInput && (
                            <div className="mb-6 mt-4">
                                <input
                                    type="text"
                                    placeholder="Search channel by name..."
                                    className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 text-lg"
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    ref={searchInputRef}
                                />
                            </div>
                        )}

                        {availableChannels.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {availableChannels.map((channel) => (
                                    <div key={channel.id} className="bg-gray-100 p-4 rounded-lg shadow-md flex flex-col items-center justify-between">
                                        <h3 className="text-xl font-semibold text-gray-800 mb-2">{channel.name}</h3>
                                        <p className="text-sm text-gray-600 mb-3">
                                            Created by: {channel.creatorUserName || 'Unknown'}
                                        </p>
                                        {channel.isStreaming && (
                                            <span className="text-sm font-bold text-red-500 mb-2">🔴 LIVE</span>
                                        )}
                                        <button
                                            onClick={() => handleJoinChannelFromExplore(channel)}
                                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mb-2"
                                        >
                                            Join
                                        </button>
                                        {(userId === channel.createdBy || isTigre) && (
                                            <button
                                                onClick={() => handleDeleteChannel(channel.name)}
                                                className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300"
                                            >
                                                Delete Channel
                                            </button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-500 italic">No channels available. Create one!</p>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen flex flex-col">
                    <MessageDisplay message={message} type={messageType} onClose={() => setMessage(null)} />
                    {isLoading && <LoadingSpinner />}
                    {currentPage === 'home' ? renderHomePage() : (currentPage === 'channel' ? renderChannelPage() : renderExplorePage())}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
