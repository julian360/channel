<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHANNEL App (GitHub Pages)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="manifest" href="/channel/manifest.json">
    <link rel="apple-touch-icon" href="/channel/icons/icon-192x192.png">
    <meta name="theme-color" content="#2563eb">

    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Import addDoc, getDocs, deleteDoc and serverTimestamp to add messages and timestamps
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, addDoc, serverTimestamp, orderBy, getDocs, deleteDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // Global variables for Firebase configuration.
        // IMPORTANT: In a real Canvas environment, these are provided automatically.
        // For local testing, your actual Firebase configuration details are now included below.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Replace 'default-app-id' if Canvas provides one
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? __firebase_config : JSON.stringify({
            apiKey: "AIzaSyBELawPeUmP2tRaL19X7Tr6MRcI9oMgdSM", // Your Firebase API key
            authDomain: "channel-jl.firebaseapp.com", // Your Firebase authentication domain
            projectId: "channel-jl", // Your Firebase project ID
            storageBucket: "channel-jl.firebasestorage.app", // Your Firebase Storage Bucket
            messagingSenderId: "350780625607", // Your Firebase app ID
            appId: "1:350780625607:web:a0275d6d6ee89b0813a4e2" // Your Firebase app ID
        });
        window.firebaseApp = initializeApp(JSON.parse(window.__firebase_config));
        console.log("DEBUG PROFUNDO: window.firebaseApp:", window.firebaseApp); // Log the full app object
        window.db = getFirestore(window.firebaseApp);
        window.auth = getAuth(window.firebaseApp);

        // Expose Firebase Firestore functions globally for the React component to use
        window.onAuthStateChanged = onAuthStateChanged;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        // Expose new Firestore functions
        window.addDoc = addDoc;
        window.serverTimestamp = serverTimestamp;
        window.orderBy = orderBy;
        window.getDocs = getDocs; // Expose getDocs for subcollection deletion
        window.deleteDoc = deleteDoc; // Expose deleteDoc for channel deletion
        window.deleteField = deleteField; // Expose deleteField for removing fields

        // NEW: Expose signInAnonymously globally
        window.signInAnonymously = signInAnonymously;


        // PWA: Register the Service Worker with the corrected path for your 'channel' repository
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/channel/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrado: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Fallo el registro del Service Worker: ', registrationError);
                    });
            });
        }
    </script>
    <style>
        /* Basic style for the body to apply the Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Spinner styles */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Style added for the back button to ensure it is clickable */
        .back-button-z-index {
            z-index: 60 !important; /* Higher than the spinner z-index (50) */
            position: relative; /* Ensures z-index is applied */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Debug message to verify code version
        console.log("DEBUG PROFUNDO: Code version: 2025-07-20-DailyFix-v53 (WebRTC Streaming - TURN & ICE Gathering Logs)");


        // Helper function to generate a random username for new users
        const generateRandomUserName = () => {
            const adjectives = ['Veloz', 'Sabio', 'Curioso', 'Audaz', 'Brillante', 'Silencioso', 'Fuerte', 'Gentil', 'Salvaje', 'Lujurioso', 'Hambriento', 'Envidioso', 'Furioso', 'Chad', 'Grande', 'Venoso', 'Oscuro', 'Chiquito'];
            const nouns = ['Lobo', 'Zorro', 'Águila', 'Tigre', 'Oso', 'Panda', 'Delfín', 'León', 'Perro', 'Gato', 'Puma', 'Pichón', 'Gorrión', 'Caballo', 'Gorila', 'Pinguino', 'Hombre', 'Mono', 'Ratón'];
            const randomAdjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            const randomNumber = Math.floor(Math.random() * 1000);
            return `${randomAdjective}${randomNoun}${randomNumber}`;
        };

        // Message component to display user feedback (replaces alert())
        const MessageDisplay = ({ message, type, onClose }) => {
            if (!message) return null;

            const bgColor = type === 'error' ? 'bg-red-100 border-red-400 text-red-700' : 'bg-green-100 border-green-400 text-green-700';
            const borderColor = type === 'error' ? 'border-red-500' : 'border-green-500';

            return (
                <div className={`fixed top-4 right-4 p-4 rounded-lg shadow-lg flex items-center justify-between z-50 ${bgColor} border ${borderColor}`}>
                    <p className="font-semibold">{message}</p>
                    <button onClick={onClose} className="ml-4 text-lg font-bold">
                        &times;
                    </button>
                </div>
            );
        };

        // Loading spinner component
        const LoadingSpinner = () => (
            // This div is still the full-screen overlay (without its own background)
            <div className="fixed inset-0 flex items-center justify-center z-50">
                {/* This new div is the container for the spinner and text, and will have the semi-transparent background */}
                <div style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)', padding: '20px', borderRadius: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                    <div className="spinner"></div>
                    <p className="ml-4 text-white text-lg">Cargando...</p>
                </div>
            </div>
        );
        // Main application component
        const App = () => {
            // State to manage the current view: 'home', 'channel' or 'explore'
            const [currentPage, setCurrentPage] = React.useState('home');
            // State to store the channel name entered by the user
            const [channelName, setChannelName] = React.useState('');
            // State to store the active channel name when viewing a channel
            const [activeChannel, setActiveChannel] = React.useState('');
            // State to store a list of available channels for the explore page
            const [availableChannels, setAvailableChannels] = React.useState([]);
            // State to store the display name chosen by the user
            const [userName, setUserName] = React.useState('');
            // State to track if the username has been confirmed
            const [userNameConfirmed, setUserNameConfirmed] = React.useState(false);
            // State to display messages to the user
            const [message, setMessage] = React.useState(null);
            const [messageType, setMessageType] = React.useState('');

            // NEW: State for the current message being typed
            const [currentMessage, setCurrentMessage] = React.useState('');
            // NEW: State for chat messages
            const [chatMessages, setChatMessages] = React.useState([]);

            // Firebase related states
            const [db, setDb] = React.useState(null);
            const [auth, setAuth] = React.useState(null);
            const [userId, setUserId] = React.useState(null);
            const [isAuthReady, setIsAuthReady] = React.useState(false);
            // NEW: State for general loading status
            const [isLoading, setIsLoading] = React.useState(true);

            // State for options menu visibility (for the channel page)
            const [showOptionsMenu, setShowOptionsMenu] = React.useState(false);
            // NEW: State for activity panel visibility (user list)
            const [showActivityPanel, setShowActivityPanel] = React.useState(false);
            // NEW: State to store channel members (historical)
            const [channelMembers, setChannelMembers] = React.useState([]);

            // NEW: WebRTC states
            const [localStream, setLocalStream] = React.useState(null);
            const [remoteStream, setRemoteStream] = React.useState(null);
            const [peerConnection, setPeerConnection] = React.useState(null);
            const [isStreaming, setIsStreaming] = React.useState(false);
            const [isReceivingStream, setIsReceivingStream] = React.useState(false);
            const [isStreamer, setIsStreamer] = React.useState(false); // To identify the streamer
            // NEW: Flag to indicate if a stream is in the process of starting
            const [isStartingStream, setIsStartingStream] = React.useState(false);


            // PWA: State for the beforeinstallprompt event
            const [deferredPrompt, setDeferredPrompt] = React.useState(null);
            // PWA: State to know if the PWA is already installed
            const [isPwaInstalled, setIsPwaInstalled] = React.useState(false);

            // NEW: States for Tigre mode
            const [showTigreCodeInput, setShowTigreCodeInput] = React.useState(false); // Controls code input visibility
            const [tigreCode, setTigreCode] = React.useState(''); // Stores the entered code
            const [isTigre, setIsTigre] = React.useState(false); // Indicates if Tigre mode is active


            // Ref for the channel name input field
            const channelInputRef = React.useRef(null);
            // NEW: Ref for the chat messages div to enable auto-scrolling
            const chatMessagesEndRef = React.useRef(null);
            // Ref for the options menu button to handle external clicks (for the channel page)
            const optionsMenuRef = React.useRef(null);
            // NEW: Ref for the explore page menu
            const exploreMenuRef = React.useRef(null);
            // NEW: Ref for the hidden file input
            const fileInputRef = React.useRef(null);
            // NEW: Refs for local and remote video elements
            const localVideoRef = React.useRef(null);
            const remoteVideoRef = React.useRef(null);


            // NEW: State for the sorting option on the explore page
            // 'activity' (most active/most recent), 'recent' (most recent by creation)
            const [sortOption, setSortOption] = React.useState('activity');
            // NEW: State to control the visibility of the explore menu
            const [showExploreMenu, setShowExploreMenu] = React.useState(false);
            // NEW: State for the search query on the explore page
            const [searchQuery, setSearchQuery] = React.useState('');
            // NEW: State to control the visibility of the search field
            const [showSearchInput, setShowSearchInput] = React.useState(false);
            // NEW: Ref for the search input
            const searchInputRef = React.useRef(null);


            // Function to display a message
            const showMessage = React.useCallback((msg, type = 'success') => {
                setMessage(msg);
                setMessageType(type);
                setTimeout(() => setMessage(null), 3000); // Clear the message after 3 seconds
            }, []);

            // NEW: Function to scroll to the end of chat messages
            const scrollToBottom = React.useCallback(() => {
                chatMessagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, []);

            // PWA: Handles the beforeinstallprompt event
            React.useEffect(() => {
                const handler = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    console.log('beforeinstallprompt event fired!');
                };
                window.addEventListener('beforeinstallprompt', handler);

                if (window.matchMedia('(display-mode: standalone)').matches) {
                    setIsPwaInstalled(true);
                }

                return () => window.removeEventListener('beforeinstallprompt', handler);
            }, []);

            // PWA: Handles the appinstalled event (when the user installs the PWA)
            React.useEffect(() => {
                const handleAppInstalled = () => {
                    setIsPwaInstalled(true);
                    setDeferredPrompt(null);
                    showMessage('Instalando CHANNEL App...', 'success');
                    console.log('PWA was installed');
                };
                window.addEventListener('appinstalled', handleAppInstalled);
                return () => window.removeEventListener('appinstalled', handleAppInstalled);
            }, [showMessage]);

            // Debugging useEffect to monitor isLoading and currentPage
            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: isLoading changed to: ${isLoading}`);
            }, [isLoading]);

            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: currentPage changed to: ${currentPage}`);
            }, [currentPage]);

            // Debugging useEffect to monitor isStartingStream
            React.useEffect(() => {
                console.log(`DEBUG PROFUNDO: isStartingStream changed to: ${isStartingStream}`);
            }, [isStartingStream]);


            // 1. Initial Firebase setup and setting db/auth states
            React.useEffect(() => {
                // Set db and auth from window after global initialization
                setDb(window.db);
                setAuth(window.auth);
                console.log("DEBUG PROFUNDO: Firebase db and auth set in React state.");
            }, []); // Empty dependency array means this runs once on mount

            // 2. Firebase Auth listener and user profile loading (depends on 'auth' being set)
            React.useEffect(() => {
                if (!auth || !db) {
                    console.log("DEBUG PROFUNDO: Auth or DB not yet available for listener setup. Skipping.");
                    return;
                }

                console.log("DEBUG PROFUNDO: Setting up onAuthStateChanged listener.");
                const unsubscribeAuth = window.onAuthStateChanged(auth, async (user) => {
                    let currentUserId = null;
                    if (user) {
                        currentUserId = user.uid;
                        setUserId(currentUserId);
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - userId established:", currentUserId);
                    } else {
                        console.log("DEBUG PROFUNDO: onAuthStateChanged - User not authenticated, attempting signInAnonymously if necessary.");
                        try {
                            const userCredential = await window.signInAnonymously(auth); // Use auth from state
                            currentUserId = userCredential.user.uid;
                            setUserId(currentUserId);
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - ANONYMOUS userId established after signIn:", currentUserId);
                        } catch (anonError) {
                            console.error("DEBUG PROFUNDO: Error during anonymous login in onAuthStateChanged:", anonError);
                            // Fallback to a client-side generated ID if anonymous sign-in fails
                            currentUserId = (Math.random().toString(36).substring(2) + Date.now().toString(36));
                            setUserId(currentUserId);
                            showMessage("Could not authenticate user. Using fallback ID. Some functions might be limited.", 'error');
                            console.log("DEBUG PROFUNDO: onAuthStateChanged - Fallback userId established due to login error:", currentUserId);
                        }
                    }

                    // *** KEY MODIFICATION HERE: Ensure db and userId are available before interacting with Firestore ***
                    if (currentUserId && db) { // Use db from state
                        const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${currentUserId}/profile`, 'userProfile');
                        try {
                            console.log("DEBUG PROFUNDO: Attempting to read/create user profile at path:", userProfileRef.path);
                            const userProfileSnap = await window.getDoc(userProfileRef);

                            let profileData;
                            if (userProfileSnap.exists()) {
                                profileData = userProfileSnap.data();
                                console.log(`DEBUG PROFUNDO: User profile loaded for ${currentUserId}.`);
                            } else {
                                // If profile doesn't exist, create it with a new random one
                                const userNameToUse = generateRandomUserName();
                                profileData = {
                                    userName: userNameToUse,
                                    isTigreActive: false
                                };
                                await window.setDoc(userProfileRef, profileData);
                                // No need to set localStorage here, userName state will be set below
                                console.log(`DEBUG PROFUNDO: User profile created for ${currentUserId}.`);
                            }

                            // Update React states based on the loaded/created profile data
                            setUserName(profileData.userName);
                            setUserNameConfirmed(true); // User name is confirmed if profile exists
                            setIsTigre(profileData.isTigreActive === true); // Ensure boolean true

                            // IMPORTANT: showTigreCodeInput is NOT set here anymore.
                            // It will be triggered by handleConfirmUserName if userName is 'Julian360'.

                        } catch (profileError) {
                            console.error("DEBUG PROFUNDO: Error loading/creating user profile from Firestore (inside onAuthStateChanged):", profileError);
                            setIsTigre(false);
                            setShowTigreCodeInput(false); // Ensure this is false on error
                            showMessage("Error loading your user profile. Check the console.", 'error');
                        }
                    } else {
                        // Fallback if currentUserId or db is not available, ensure Tigre mode is off
                        setIsTigre(false);
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: No userId or db available to load profile. isTigre set to false.");
                    }
                    setIsAuthReady(true);
                    setIsLoading(false);
                    console.log("DEBUG PROFUNDO: isAuthReady set to true.");
                });

                return () => unsubscribeAuth();
            }, [auth, db, showMessage]); // Dependencies: auth and db states


            React.useEffect(() => {
                const handlePopState = (event) => {
                    if (event.state && event.state.page) {
                        setCurrentPage(event.state.page);
                        // Stop streaming if navigating away from channel page
                        if (event.state.page !== 'channel' && peerConnection) {
                            peerConnection.close();
                            setPeerConnection(null);
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            setLocalStream(null);
                            setRemoteStream(null);
                            setIsStreaming(false);
                            setIsReceivingStream(false);
                            setIsStreamer(false);
                        }
                    } else {
                        setCurrentPage('home');
                        // Stop streaming if navigating away from channel page
                        if (peerConnection) {
                            peerConnection.close();
                            setPeerConnection(null);
                            if (localStream) localStream.getTracks().forEach(track => track.stop());
                            setLocalStream(null);
                            setRemoteStream(null);
                            setIsStreaming(false);
                            setIsReceivingStream(false);
                            setIsStreamer(false);
                        }
                    }
                };

                window.addEventListener('popstate', handlePopState);
                window.history.pushState({ page: currentPage }, document.title, null);
                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, [currentPage, peerConnection, localStream]);

            React.useEffect(() => {
                if (currentPage && (!window.history.state || window.history.state.page !== currentPage)) {
                    window.history.pushState({ page: currentPage }, document.title, null);
                }
            }, [currentPage]);

            React.useEffect(() => {
                const handleClickOutside = (event) => {
                    if (optionsMenuRef.current && !optionsMenuRef.current.contains(event.target)) {
                        setShowOptionsMenu(false);
                        setShowActivityPanel(false);
                    }
                    if (exploreMenuRef.current && !exploreMenuRef.current.contains(event.target)) {
                        setShowExploreMenu(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [optionsMenuRef, exploreMenuRef]);

            const fetchChannels = React.useCallback(async () => {
                if (!isAuthReady || !db) {
                    console.log("DEBUG PROFUNDO: fetchChannels - Firebase not ready or db is null. Exiting.");
                    return;
                }
                setIsLoading(true);
                const channelsColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels`);
                const q = window.query(channelsColRef);

                try {
                    const snapshot = await window.getDocs(q);
                    const channelsData = snapshot.docs.map(doc => ({
                        id: doc.id,
                        name: doc.data().displayName || doc.id,
                        createdAt: doc.data().createdAt,
                        createdBy: doc.data().createdBy,
                        creatorUserName: doc.data().creatorUserName,
                        lastActivity: doc.data().lastActivity,
                        isStreaming: doc.data().isStreaming || false // NEW: Add isStreaming status
                    }));

                    let processedChannels = [...channelsData];

                    if (sortOption === 'activity') {
                        processedChannels.sort((a, b) => {
                            const dateA = a.lastActivity ? a.lastActivity.toDate() : new Date(a.createdAt);
                            const dateB = b.lastActivity ? b.lastActivity.toDate() : new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    } else if (sortOption === 'recent') {
                        processedChannels.sort((a, b) => {
                            const dateA = new Date(a.createdAt);
                            const dateB = new Date(b.createdAt);
                            return dateB.getTime() - dateA.getTime();
                        });
                    }

                    if (searchQuery) {
                        processedChannels = processedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(searchQuery.toLowerCase())
                        );
                    }

                    setAvailableChannels(processedChannels);
                    console.log("DEBUG PROFUNDO: Channels fetched and processed:", processedChannels);
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error fetching channels:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error loading channels. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    setIsLoading(false);
                }
            }, [isAuthReady, db, sortOption, searchQuery, showMessage, setIsLoading, setAvailableChannels]);


            React.useEffect(() => {
                let intervalId;
                if (currentPage === 'explore') {
                    fetchChannels();
                    intervalId = setInterval(fetchChannels, 60000);
                }

                return () => {
                    if (intervalId) {
                        clearInterval(intervalId);
                    }
                };
            }, [currentPage, fetchChannels]);


            React.useEffect(() => {
                if (showSearchInput && searchInputRef.current) {
                    searchInputRef.current.focus();
                }
            }, [showSearchInput]);


            React.useEffect(() => {
                if (isAuthReady && db && activeChannel && currentPage === 'channel') {
                    const normalizedActiveChannel = activeChannel.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    const q = window.query(messagesColRef, window.orderBy('timestamp'));

                    const unsubscribe = window.onSnapshot(q, (snapshot) => {
                        const messagesData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChatMessages(messagesData);
                        scrollToBottom();
                        console.log("DEBUG PROFUNDO: Chat messages updated:", messagesData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching chat messages:", error);
                        if (error.code === 'unavailable' || error.code === 'permission-denied') {
                            showMessage("Connection error or permissions when loading messages. Check Firestore rules.", 'error');
                        } else {
                            showMessage("Error loading chat messages. Check the console.", 'error');
                        }
                    });

                    const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/members`);
                    const unsubscribeMembers = window.onSnapshot(membersColRef, (snapshot) => {
                        const membersData = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setChannelMembers(membersData);
                        console.log("DEBUG PROFUNDO: Channel members updated:", membersData);
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching channel members:", error);
                    });

                    // NEW: Listen for streaming status of the channel
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    const unsubscribeChannelStatus = window.onSnapshot(channelDocRef, async (docSnap) => {
                        if (docSnap.exists()) {
                            const channelData = docSnap.data();
                            const currentStreamerIdInFirestore = channelData.streamerId;
                            const isChannelStreamingInFirestore = channelData.isStreaming || false;

                            console.log("DEBUG PROFUNDO: onSnapshot - Channel data from Firestore:", channelData);
                            console.log("DEBUG PROFUNDO: onSnapshot - Channel streaming status in Firestore:", isChannelStreamingInFirestore, "Streamer ID in Firestore:", currentStreamerIdInFirestore, "Current User ID:", userId);
                            console.log("DEBUG PROFUNDO: onSnapshot - Local isStreaming:", isStreaming, "Local isReceivingStream:", isReceivingStream, "Local isStreamer:", isStreamer);

                            // Logic for viewers:
                            // If channel is streaming, there's a streamer ID, and it's not us, AND we are not already receiving a stream
                            if (isChannelStreamingInFirestore && currentStreamerIdInFirestore && currentStreamerIdInFirestore !== userId && !isReceivingStream) {
                                // Add a check here to ensure we are not in the process of starting our own stream.
                                // This is where isStartingStream is useful.
                                if (!isStartingStream) {
                                    showMessage(`Stream activo en este canal por ${channelData.streamerUserName || 'alguien'}. Uniéndote como espectador...`, 'info');
                                    console.log("DEBUG PROFUNDO: Attempting to join stream as viewer.");
                                    await startReceivingStream(normalizedActiveChannel, currentStreamerIdInFirestore);
                                } else {
                                    console.log("DEBUG PROFUNDO: onSnapshot - isStartingStream is true. Ignoring viewer join to prevent race condition during streamer setup.");
                                }
                            }
                            // Logic for viewers to stop receiving if stream ends
                            else if (!isChannelStreamingInFirestore && currentStreamerIdInFirestore !== userId && isReceivingStream) {
                                showMessage("El stream ha terminado.", 'info');
                                console.log("DEBUG PROFUNDO: Stream ended (viewer side).");
                                setTimeout(() => stopStreaming(), 500);
                            }
                            // Logic for streamer to ensure their local state matches Firestore (if they stopped it elsewhere)
                            // This also handles cases where the streamer might have left the channel or their stream died
                            else if (isStreaming && isStreamer && (!isChannelStreamingInFirestore || currentStreamerIdInFirestore !== userId)) {
                                if (!isStartingStream) { // Only stop if we are not actively trying to start it
                                    console.warn("DEBUG PROFUNDO: Streamer local state is active, but Firestore shows inactive or different streamer. Forcing local stream stop.");
                                    console.trace("DEBUG PROFUNDO: Call stack for forced stopStreaming (streamer side).");
                                    showMessage("Tu stream ha terminado o ha sido desconectado (detectado por Firestore).", 'info');
                                    setTimeout(() => stopStreaming(), 500);
                                } else {
                                    console.log("DEBUG PROFUNDO: onSnapshot - Streamer is starting stream. Ignoring temporary Firestore state mismatch.");
                                }
                            }
                        }
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error fetching channel streaming status:", error);
                        if (isStreaming || isReceivingStream) {
                            showMessage("Error al obtener el estado del stream. Deteniendo el stream.", 'error');
                            setTimeout(() => stopStreaming(), 500);
                        }
                    });


                    return () => {
                        unsubscribe();
                        unsubscribeMembers();
                        unsubscribeChannelStatus(); // Clean up listener
                        // Ensure WebRTC connections are closed when leaving the channel
                        if (peerConnection) {
                            peerConnection.close();
                            setPeerConnection(null);
                        }
                        if (localStream) {
                            localStream.getTracks().forEach(track => track.stop());
                            setLocalStream(null);
                        }
                        setRemoteStream(null);
                        setIsStreaming(false);
                        setIsReceivingStream(false);
                        setIsStreamer(false);
                    };
                } else {
                    setChatMessages([]);
                    setChannelMembers([]);
                    // Ensure WebRTC connections are closed when leaving the channel
                    if (peerConnection) {
                        peerConnection.close();
                        setPeerConnection(null);
                    }
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        setLocalStream(null);
                    }
                    setRemoteStream(null);
                    setIsStreaming(false);
                    setIsReceivingStream(false);
                    setIsStreamer(false);
                    console.log("DEBUG PROFUNDO: Cleaning up channel messages, members, and streaming state.");
                }
            }, [isAuthReady, db, activeChannel, currentPage, showMessage, scrollToBottom, userId, isReceivingStream, peerConnection, localStream, isStreaming, isStartingStream]); // Added isStartingStream to dependencies

            const handleConfirmUserName = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleConfirmUserName - Initiated.");
                if (userName.trim() === '') {
                    showMessage('Please enter a username.', 'error');
                    return;
                }
                if (userName.trim().length > 48) {
                    showMessage('Username cannot exceed 48 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleConfirmUserName - Firebase is not ready or db/userId is null.");
                    showMessage("Authentication is not ready. Please try again.", 'error');
                    return;
                }
                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleConfirmUserName - isLoading set to true.");
                try {
                    const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Attempting to save user profile.");
                    let profileUpdate = { userName: userName.trim() };

                    // Only set isTigreActive to false here, it will be set to true by handleTigreCodeSubmit
                    profileUpdate.isTigreActive = false;

                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Saving user profile:", { userId: userId, userName: userName.trim(), isTigreActive: profileUpdate.isTigreActive });
                    await window.setDoc(userProfileRef, profileUpdate, { merge: true });
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - User profile saved.");
                    // No need to set localStorage here, userName state is already updated
                    setUserNameConfirmed(true);
                    showMessage('Username confirmed!', 'success');
                    setIsTigre(profileUpdate.isTigreActive); // This will be false here

                    // NEW LOGIC: Only show Tigre code input IF userName is Julian360 AND isTigre is NOT active
                    if (userName.trim() === 'Julian360' && !profileUpdate.isTigreActive) {
                        setShowTigreCodeInput(true);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - User is Julian360 and Tigre mode inactive. Showing Tigre code input.");
                    } else {
                        setShowTigreCodeInput(false);
                        console.log("DEBUG PROFUNDO: handleConfirmUserName - User is NOT Julian360 or Tigre mode active. Hiding Tigre code input.");
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error saving username (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error saving username. Please try again.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleConfirmUserName - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage, setIsLoading, setShowTigreCodeInput, setIsTigre, setUserNameConfirmed]);

            const handleTigreCodeSubmit = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - current userId:", userId);
                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Entered code:", tigreCode);
                if (parseInt(tigreCode) === (15476 * 1000 + 767)) {
                    setIsTigre(true);
                    showMessage('Tigre mode activated. You can now delete any channel.', 'success');
                    setShowTigreCodeInput(false);

                    if (db && userId) {
                        try {
                            const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Attempting to activate Tigre mode in Firestore for userId:", userId, "with isTigreActive: true (boolean).");
                            await window.setDoc(userProfileRef, { isTigreActive: true }, { merge: true });
                            console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Tigre mode activated in Firestore for user:", userId);
                            const updatedProfileSnap = await window.getDoc(userProfileRef);
                            if (updatedProfileSnap.exists()) {
                                console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - User profile READ after update:", updatedProfileSnap.data());
                            }
                        } catch (error) {
                            console.error("DEBUG PROFUNDO: handleTigreCodeSubmit - Error activating Tigre mode in Firestore:", error);
                            showMessage("Error saving Tigre status. Please try again.", 'error');
                        }
                    }

                } else {
                    showMessage('Incorrect code. Please try again.', 'error');
                    setTigreCode('');
                    console.log("DEBUG PROFUNDO: handleTigreCodeSubmit - Incorrect code.");
                }
            }, [tigreCode, showMessage, setIsTigre, setShowTigreCodeInput, setTigreCode, db, userId]);

            const handleCreateChannel = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: handleCreateChannel - Initiated.");
                if (channelName.trim() === '') {
                    showMessage('Please enter a name for the channel.', 'error');
                    if (channelInputRef.current) {
                        channelInputRef.current.focus();
                    }
                    return;
                }
                if (channelName.trim().length > 128) {
                    showMessage('Channel name cannot exceed 128 characters.', 'error');
                    return;
                }
                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleCreateChannel - Firebase is not ready yet. Please wait.");
                    showMessage("Authentication is not ready. Please try again.", 'error');
                    return;
                }

                const normalizedChannelName = channelName.trim().toLowerCase();
                const originalChannelInput = channelName.trim();

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleCreateChannel - isLoading set to true.");
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Attempting to get channel doc.");
                    const docSnap = await window.getDoc(channelDocRef);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Channel doc snap received.");

                    if (docSnap.exists()) {
                        const existingChannelDisplayName = docSnap.data().displayName || normalizedChannelName;
                        setActiveChannel(existingChannelDisplayName);
                        setCurrentPage('channel');
                        showMessage(`You have joined the channel: ${existingChannelDisplayName}`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Existing channel joined:", existingChannelDisplayName);
                    } else {
                        await window.setDoc(channelDocRef, {
                            name: normalizedChannelName,
                            displayName: originalChannelInput,
                            createdAt: new Date().toISOString(),
                            createdBy: userId,
                            creatorUserName: userName,
                            lastActivity: window.serverTimestamp(),
                            isStreaming: false, // NEW: Initialize streaming status
                            streamerId: null // NEW: Initialize streamer ID
                        });
                        setActiveChannel(originalChannelInput);
                        setCurrentPage('channel');
                        showMessage(`Channel "${originalChannelInput}" created and you have joined!`, 'success');
                        console.log("DEBUG PROFUNDO: handleCreateChannel - Channel created and joined:", originalChannelInput);
                    }

                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Attempting to add member.");
                    await window.setDoc(memberDocRef, {
                        userName: userName,
                        joinedAt: window.serverTimestamp()
                    }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Member added. Setting isLoading to false.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error creating or joining channel (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error creating or joining channel. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleCreateChannel - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [channelName, userName, isAuthReady, db, userId, showMessage, setIsLoading, setCurrentPage, setActiveChannel]);

            const handleJoinChannelFromExplore = React.useCallback(async (channelToJoin) => {
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Initiated for channel:", channelToJoin.name);
                setActiveChannel(channelToJoin.name);
                setCurrentPage('channel');
                showMessage(`You have joined the channel: ${channelToJoin.name}`, 'success');
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Joined channel:", channelToJoin.name);

                if (!isAuthReady || !db || !userId || !userName) {
                    console.warn("DEBUG PROFUNDO: handleJoinChannelFromExplore - Firebase, user, or username not ready. Cannot add member.");
                    return;
                }

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - isLoading set to true.");
                try {
                    const normalizedChannelName = channelToJoin.name.toLowerCase();
                    const memberDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/members`, userId);
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Attempting to add member.");
                    await window.setDoc(memberDocRef, {
                        userName: userName,
                        joinedAt: window.serverTimestamp()
                    }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Member added. Setting isLoading to false.");
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error adding member when joining channel (catch block):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                    } else {
                        showMessage("Error adding member to channel. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleJoinChannelFromExplore - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [userName, isAuthReady, db, userId, showMessage, setCurrentPage, setActiveChannel]);

            const handleSendMessage = React.useCallback(async () => {
                if (currentMessage.trim() === '') {
                    return;
                }
                if (!isAuthReady || !db || !userId || !activeChannel || !userName) {
                    console.warn("DEBUG PROFUNDO: handleSendMessage - Firebase, user, channel or username are not ready. Cannot send message.");
                    showMessage("Could not send message. Application is not ready.", 'error');
                    return;
                }

                const normalizedActiveChannel = activeChannel.toLowerCase();

                try {
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    console.log("DEBUG PROFUNDO: handleSendMessage - Sending message:", currentMessage.trim(), "to channel:", normalizedActiveChannel);
                    await window.addDoc(messagesColRef, {
                        text: currentMessage.trim(),
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                    });
                    setCurrentMessage('');
                    scrollToBottom();

                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    await window.setDoc(channelDocRef, { lastActivity: window.serverTimestamp() }, { merge: true });
                    console.log("DEBUG PROFUNDO: handleSendMessage - Channel last activity updated.");

                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error sending message:", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions when sending message. Check Firestore rules.", 'error');
                    } else {
                        showMessage("Error sending message. Check the console.", 'error');
                    }
                }
            }, [currentMessage, userName, activeChannel, isAuthReady, db, userId, showMessage, scrollToBottom]);

            const handleDeleteChannel = React.useCallback(async (channelDisplayName) => {
                console.log("DEBUG PROFUNDO: handleDeleteChannel - current userId:", userId);
                console.log("DEBUG PROFUNDO: handleDeleteChannel - Initiating deletion for channel:", channelDisplayName);
                const userConfirmed = await new Promise((resolve) => {
                    const confirmModal = document.createElement('div');
                    confirmModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    confirmModal.innerHTML = `
                        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
                            <p class="mb-4 text-lg">Are you sure you want to delete channel "${channelDisplayName}"? This action is irreversible.</p>
                            <button id="confirmDelete" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg mr-2">Yes, Delete</button>
                            <button id="cancelDelete" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg">Cancel</button>
                        </div>
                    `;
                    document.body.appendChild(confirmModal);

                    document.getElementById('confirmDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(true);
                    };
                    document.getElementById('cancelDelete').onclick = () => {
                        document.body.removeChild(confirmModal);
                        resolve(false);
                    };
                });

                if (!userConfirmed) {
                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Deletion canceled by user.");
                    return;
                }

                if (!isAuthReady || !db || !userId) {
                    console.warn("DEBUG PROFUNDO: handleDeleteChannel - Firebase is not ready or db/userId is null. Cannot delete.");
                    showMessage("Firebase is not ready or you don't have a user ID. Cannot delete channel.", 'error');
                    return;
                }

                const normalizedChannelId = channelDisplayName.toLowerCase();

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: handleDeleteChannel - isLoading set to true.");
                try {
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelId);
                    const docSnap = await window.getDoc(channelDocRef);

                    if (!docSnap.exists()) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Channel does not exist.");
                        showMessage("The channel does not exist.", 'error');
                        setIsLoading(false);
                        return;
                    }

                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Values for permission evaluation:");
                    console.log("DEBUG PROFUNDO:   - userId (current):", userId);
                    console.log("DEBUG PROFUNDO:   - isTigre (React state):", isTigre);
                    console.log("DEBUG PROFUNDO:   - channel.createdBy (from Firestore):", docSnap.data().createdBy);
                    console.log("DEBUG PROFUNDO:   - userId === channel.createdBy?:", userId === docSnap.data().createdBy);

                    if (isTigre || docSnap.data().createdBy === userId) {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permission GRANTED. Initiating subcollection and channel deletion.");

                        const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`);
                        const messagesSnapshot = await window.getDocs(messagesColRef);
                        const deleteMessagePromises = [];
                        messagesSnapshot.forEach(msgDoc => {
                            deleteMessagePromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/messages`, msgDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Deleting ${deleteMessagePromises.length} messages.`);
                        await Promise.all(deleteMessagePromises);

                        const membersColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`);
                        const membersSnapshot = await window.getDocs(membersColRef);
                        const deleteMemberPromises = [];
                        membersSnapshot.forEach(memberDoc => {
                            deleteMemberPromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelId}/members`, memberDoc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: handleDeleteChannel - Deleting ${deleteMemberPromises.length} members.`);
                        await Promise.all(deleteMemberPromises);


                        await window.deleteDoc(channelDocRef);
                        showMessage(`Channel "${channelDisplayName}" successfully deleted.`, 'success');
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Main channel deleted.");
                        fetchChannels();
                    } else {
                        console.log("DEBUG PROFUNDO: handleDeleteChannel - Permission DENIED. Conditions not met.");
                        showMessage("You do not have permission to delete this channel.", 'error');
                    }
                } catch (error) {
                    console.error("DEBUG PROFUNDO: Error deleting channel (catch general):", error);
                    if (error.code === 'unavailable' || error.code === 'permission-denied') {
                        showMessage("Connection error or permissions. Make sure your Firestore rules are correct and you have an internet connection.", 'error');
                        } else {
                        showMessage("Error deleting channel. Check the console.", 'error');
                    }
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: handleDeleteChannel - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [isAuthReady, db, userId, isTigre, showMessage, setIsLoading, fetchChannels]);

            // WebRTC Functions
            const createPeerConnection = React.useCallback((currentAuthUserId) => { // Pass userId as argument
                // Define ICE servers. Add a TURN server if you have one for better connectivity.
                // Example with a public STUN server (always recommended):
                const iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    // IMPORTANT: Replace with your actual TURN server details if you have one.
                    // {
                    //     urls: 'turn:YOUR_TURN_SERVER_URL:YOUR_TURN_SERVER_PORT',
                    //     username: 'YOUR_TURN_USERNAME',
                    //     credential: 'YOUR_TURN_PASSWORD'
                    // }
                ];

                const pc = new RTCPeerConnection({ iceServers: iceServers });

                pc.onicecandidate = async (event) => {
                    if (event.candidate) {
                        console.log("DEBUG PROFUNDO: ICE candidate generated:", event.candidate.type, event.candidate.protocol, event.candidate.address);
                        // Use the userId passed as argument
                        console.log("DEBUG PROFUNDO: ICE candidate generated. currentAuthUserId (passed to PC):", currentAuthUserId);

                        if (!currentAuthUserId) {
                            console.error("DEBUG PROFUNDO: No authenticated user ID available for ICE candidate. Aborting.");
                            return;
                        }
                        const normalizedActiveChannel = activeChannel.toLowerCase();
                        await window.addDoc(window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/iceCandidates`), {
                            candidate: event.candidate.toJSON(),
                            senderId: currentAuthUserId, // Use directly obtained user ID
                            timestamp: window.serverTimestamp(),
                        });
                    } else {
                        console.log("DEBUG PROFUNDO: ICE gathering complete.");
                    }
                };

                pc.onicegatheringstatechange = () => {
                    console.log(`DEBUG PROFUNDO: PeerConnection iceGatheringState changed to: ${pc.iceGatheringState}`);
                };

                pc.ontrack = (event) => {
                    console.log("DEBUG PROFUNDO: Remote track received:", event.streams[0]);
                    setRemoteStream(event.streams[0]);
                    setIsReceivingStream(true);
                };

                // NEW: Add signaling state change listener
                pc.onsignalingstatechange = () => {
                    console.log(`DEBUG PROFUNDO: PeerConnection signalingState changed to: ${pc.signalingState}`);
                };

                // NEW: Add negotiation needed listener
                pc.onnegotiationneeded = () => {
                    console.log("DEBUG PROFUNDO: PeerConnection onnegotiationneeded event fired.");
                };


                // Removed setPeerConnection(pc) from here. It will be set in startStreaming.
                return pc;
            }, [activeChannel, db]);

            // NEW: Function to request media permissions explicitly
            const requestMediaPermissions = React.useCallback(async () => {
                try {
                    console.log("DEBUG PROFUNDO: Requesting media permissions explicitly...");
                    // REMOVED: stream.getTracks().forEach(track => track.stop());
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    // Explicitly stop tracks to release camera/mic after permission check
                    stream.getTracks().forEach(track => track.stop());
                    showMessage("Camera and microphone permissions granted!", 'success');
                    console.log("DEBUG PROFUNDO: Media permissions successfully granted.");
                } catch (error) {
                    console.error(`DEBUG PROFUNDO: Error requesting media permissions: Name: ${error.name}, Message: ${error.message}`, error);
                    showMessage(`Error requesting media permissions: ${error.message}. Please check your browser settings.`, 'error');
                }
            }, [showMessage]);


              // NEW: WebRTC: Function to start streaming (get camera/mic, create peer connection, offer)
  // NEW: WebRTC: Function to start streaming (get camera/mic, create peer connection, offer)
        const startStreaming = React.useCallback(async () => {
            console.log("DEBUG PROFUNDO: startStreaming - Initiated.");

            // Get the current user ID directly from Firebase Auth right before using it
            const currentAuthUser = auth.currentUser; // Use auth from state
            const currentAuthUserId = currentAuthUser ? currentAuthUser.uid : null;

            // Ensure auth and db are ready and currentAuthUserId is set
            if (!db || !currentAuthUserId || !activeChannel || !userName) {
                showMessage("Database or user information not ready. Cannot start stream.", 'error');
                console.warn("DEBUG PROFUNDO: startStreaming - DB, userId or userName not ready.");
                return;
            }

            // Prevent multiple stream attempts
            if (isStartingStream || isStreaming || isReceivingStream) {
                console.warn("DEBUG PROFUNDO: Stream already active or in process of starting. Aborting startStreaming.");
                showMessage("Ya hay un stream activo o en proceso de inicio.", 'info');
                return;
            }

            setIsStartingStream(true); // Set flag to true at the beginning
            setIsLoading(true); // Show loading spinner
            console.log("DEBUG PROFUNDO: startStreaming - isStartingStream set to true. isLoading set to true.");

            let pcInstance; // Use a local variable for the PC instance
            let stream; // Declare stream here

            try {
                // Get local media stream
                console.log("DEBUG PROFUNDO: Attempting to get user media (video and audio).");
                stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                setLocalStream(stream);
                if (localVideoRef.current) {
                    localVideoRef.current.srcObject = stream;
                    console.log("DEBUG PROFUNDO: Local video stream attached to video element.");
                }

                // WebRTC Peer Connection setup - NOW WITH XIRSYS TURN SERVERS
                const servers = {
                    iceServers: [
                        {
                            urls: [ "stun:eu-turn3.xirsys.com" ]
                        },
                        {
                            username: "O7tpKs7JoPXBgQzCEfvaK2zC-wicd4zk0jZpfeF3HyKScXVrwJhbpBbiOhzCAuBLAAAAAGh8zbdqdWxpYW4zNjA=",
                            credential: "978d21a4-6559-11f0-97ea-0242ac140004",
                            urls: [
                                "turn:eu-turn3.xirsys.com:80?transport=udp",
                                "turn:eu-turn3.xirsys.com:3478?transport=udp",
                                "turn:eu-turn3.xirsys.com:80?transport=tcp",
                                "turn:eu-turn3.xirsys.com:3478?transport=tcp",
                                "turns:eu-turn3.xirsys.com:443?transport=tcp",
                                "turns:eu-turn3.xirsys.com:5349?transport=tcp"
                            ]
                        }
                    ]
                };
                console.log("DEBUG PROFUNDO: RTCPeerConnection initialized with ICE servers:", servers);
                pcInstance = new RTCPeerConnection(servers); // Assign to local variable
                setPeerConnection(pcInstance); // Set the state here
                console.log("DEBUG PROFUNDO: startStreaming - New PeerConnection created and set to state.");


                // NEW: Add onnegotiationneeded listener
                pcInstance.onnegotiationneeded = () => {
                    console.log("DEBUG PROFUNDO: PeerConnection onnegotiationneeded event fired. This indicates a need to create an offer.");
                };

                // Add onicegatheringstatechange listener immediately after PC creation
                pcInstance.onicegatheringstatechange = () => {
                    console.log(`DEBUG PROFUNDO: PeerConnection iceGatheringState changed to: ${pcInstance.iceGatheringState}`);
                };

                // Add local stream tracks to the peer connection
                stream.getTracks().forEach(track => {
                    pcInstance.addTrack(track, stream);
                    console.log("DEBUG PROFUNDO: Added local track to peer connection:", track.kind);
                });

                // Normalize activeChannel for Firestore paths
                const normalizedActiveChannel = activeChannel.toLowerCase();

                // Handle ICE candidates
                pcInstance.onicecandidate = async (event) => {
                    if (event.candidate) {
                        console.log("DEBUG PROFUNDO: ICE Candidate found:", event.candidate);
                        // Save ICE candidate to Firestore
                        const candidateRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/${currentAuthUserId}/candidates`, event.candidate.sdpMid || 'video' + '_' + event.candidate.sdpMLineIndex + '_' + event.candidate.candidate.split(' ')[4]);
                        await window.setDoc(candidateRef, event.candidate.toJSON());
                        console.log("DEBUG PROFUNDO: ICE Candidate saved to Firestore:", event.candidate.toJSON());
                    } else {
                        console.log("DEBUG PROFUNDO: All ICE candidates gathered.");
                    }
                };

                // Handle remote stream when it arrives
                pcInstance.ontrack = (event) => {
                    console.log("DEBUG PROFUNDO: Remote track received:", event.streams[0]);
                    setRemoteStream(event.streams[0]);
                    if (remoteVideoRef.current) {
                        remoteVideoRef.current.srcObject = event.streams[0];
                        setIsReceivingStream(true);
                        console.log("DEBUG PROFUNDO: Remote stream attached to video element.");
                    }
                };

                // Create and set offer
                console.log("DEBUG PROFUNDO: Creating WebRTC offer. Current signalingState:", pcInstance.signalingState); // NEW LOG
                const offer = await pcInstance.createOffer();
                console.log("DEBUG PROFUNDO: Offer created:", offer);

                // Specific try-catch for setLocalDescription with a timeout
                const setLocalDescriptionPromise = pcInstance.setLocalDescription(offer);
                const timeoutPromise = new Promise((resolve, reject) =>
                    setTimeout(() => reject(new Error('setLocalDescription timed out')), 15000) // Increased timeout to 15 seconds
                );

                try {
                    console.log("DEBUG PROFUNDO: Attempting to set local description (with timeout). Awaiting Promise.race."); // NEW LOG
                    await Promise.race([setLocalDescriptionPromise, timeoutPromise]);
                    console.log("DEBUG PROFUNDO: Offer set as local description. Local description object:", pcInstance.localDescription);
                    console.log(`DEBUG PROFUNDO: PeerConnection state AFTER setLocalDescription - signalingState: ${pcInstance.signalingState}, iceGatheringState: ${pcInstance.iceGatheringState}`);
                    showMessage("Local description set successfully!", 'success');
                } catch (setLocalDescError) {
                    console.error(`DEBUG PROFUNDO: Error setting local description (WebRTC): Name: ${setLocalDescError.name}, Message: ${setLocalDescError.message}`, setLocalDescError);
                    showMessage(`Error al establecer la descripción local del stream: ${setLocalDescError.message}.`, 'error');
                    // Clean up WebRTC resources on error
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop());
                    }
                    if (pcInstance) {
                        pcInstance.close();
                    }
                    setLocalStream(null);
                    setPeerConnection(null);
                    setIsStreaming(false);
                    setIsStreamer(false);
                    setIsLoading(false);
                    setIsStartingStream(false);
                    return; // Exit if setLocalDescription fails
                }

                // Save offer to Firestore (This block is moved inside the successful try-catch for setLocalDescription)
                const offerRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc`, 'offer');
                await window.setDoc(offerRef, {
                    sdp: pcInstance.localDescription.sdp, // Use localDescription after it's set
                    type: pcInstance.localDescription.type, // Use localDescription after it's set
                    senderId: currentAuthUserId,
                    senderUserName: userName,
                    timestamp: window.serverTimestamp()
                });
                console.log("DEBUG PROFUNDO: WebRTC offer saved to Firestore:", pcInstance.localDescription.toJSON());

                // Update channel status in Firestore to indicate streaming
                const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                await window.setDoc(channelDocRef, {
                    isStreaming: true,
                    streamerId: currentAuthUserId,
                    streamerUserName: userName,
                    lastActivity: window.serverTimestamp()
                }, { merge: true });
                console.log("DEBUG PROFUNDO: Channel status updated in Firestore: isStreaming=true.");

                setIsStreaming(true);
                setIsStreamer(true); // Mark current user as streamer
                showMessage("Stream iniciado correctamente!", 'success');
                console.log("DEBUG PROFUNDO: Stream started successfully. isStreaming=true, isStreamer=true.");

                // Listen for answers from viewers
                const answerRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc`, 'answer');
                const unsubscribeAnswer = window.onSnapshot(answerRef, async (docSnap) => {
                    if (docSnap.exists() && docSnap.data().type === 'answer' && docSnap.data().receiverId === currentAuthUserId && !pcInstance.currentRemoteDescription) {
                        const answer = new RTCSessionDescription(docSnap.data());
                        console.log("DEBUG PROFUNDO: Received answer from Firestore:", answer);
                        await pcInstance.setRemoteDescription(answer);
                        console.log("DEBUG PROFUNDO: Remote description (answer) set.");
                        showMessage("Respuesta de espectador recibida.", 'info');

                        // After setting the answer, collect and add ICE candidates from viewer
                        const viewerCandidatesRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/${docSnap.data().senderId}/candidates`);
                        const candidateSnapshot = await window.getDocs(viewerCandidatesRef);
                        candidateSnapshot.forEach(async (candidateDoc) => {
                            if (candidateDoc.exists()) {
                                try {
                                    const candidate = new RTCIceCandidate(candidateDoc.data());
                                    await pcInstance.addIceCandidate(candidate);
                                    console.log("DEBUG PROFUNDO: Added viewer ICE candidate:", candidate);
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error adding viewer ICE candidate:", e);
                                }
                            }
                        });
                    }
                }, (error) => {
                    console.error("DEBUG PROFUNDO: Error listening for answer:", error);
                });

                // Listen for candidates from viewers (after answer is set)
                const viewerCandidatesListener = window.onSnapshot(window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/webrtc/viewerCandidates`), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === "added") {
                            const candidateData = change.doc.data();
                            if (candidateData.senderId !== currentAuthUserId) {
                                try {
                                    const candidate = new RTCIceCandidate(candidateData);
                                    if (pcInstance.remoteDescription) {
                                        await pcInstance.addIceCandidate(candidate);
                                        console.log("DEBUG PROFUNDO: Added viewer candidate (via listener):", candidate);
                                    } else {
                                        console.log("DEBUG PROFUNDO: Remote description not set yet, deferring viewer candidate:", candidate);
                                    }
                                } catch (e) {
                                    console.error("DEBUG PROFUNDO: Error adding viewer candidate (via listener):", e);
                                }
                            }
                        }
                    });
                }, (error) => {
                    console.error("DEBUG PROFUNDO: Error listening for viewer candidates:", error);
                });

                // Clean up listeners when component unmounts or stream stops
                pcInstance.onconnectionstatechange = () => {
                    console.log(`DEBUG PROFUNDO: RTCPeerConnection state: ${pcInstance.connectionState}`);
                    if (pcInstance.connectionState === 'disconnected' || pcInstance.connectionState === 'failed' || pcInstance.connectionState === 'closed') {
                        console.log("DEBUG PROFUNDO: PeerConnection disconnected/failed/closed. Stopping stream.");
                        showMessage("Stream desconectado debido a un error de conexión.", 'error');
                        setTimeout(() => stopStreaming(), 500);
                        unsubscribeAnswer();
                        viewerCandidatesListener(); // Unsubscribe candidates listener
                    }
                };

                return () => {
                    unsubscribeAnswer();
                    viewerCandidatesListener(); // Unsubscribe candidates listener
                };

            } catch (error) {
                console.error("DEBUG PROFUNDO: Error starting stream:", error);
                showMessage("Error al iniciar el stream: " + error.message, 'error');
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                if (pcInstance) { // Use local 'pcInstance'
                    pcInstance.close();
                }
                setLocalStream(null);
                setRemoteStream(null);
                setIsStreaming(false);
                setIsReceivingStream(false);
                setIsStreamer(false);
                setPeerConnection(null);
            } finally {
                setIsStartingStream(false);
                setIsLoading(false);
                console.log("DEBUG PROFUNDO: startStreaming - Finally block executed. isStartingStream set to false. isLoading set to false.");
            }
        }, [db, userId, userName, showMessage, isStartingStream, isStreaming, isReceivingStream, localStream, peerConnection, activeChannel, auth]);

            const startReceivingStream = React.useCallback(async (channelName, streamerId) => {
                console.log("DEBUG PROFUNDO: startReceivingStream - Initiated for channel:", channelName, "from streamer:", streamerId);
                // Get the current user ID directly from Firebase Auth right before using it
                const currentAuthUser = auth.currentUser; // Use auth from state
                const currentAuthUserId = currentAuthUser ? currentAuthUser.uid : null;

                if (!isAuthReady || !db || !currentAuthUserId || !channelName || currentAuthUserId === streamerId || isReceivingStream) {
                    console.log("DEBUG PROFUNDO: Not ready to receive stream or already receiving or is streamer. currentAuthUserId:", currentAuthUserId, "streamerId:", streamerId, "isReceivingStream:", isReceivingStream);
                    return;
                }

                setIsLoading(true);
                console.log("DEBUG PROFUNDO: startReceivingStream - isLoading set to true.");
                let pcInstance; // Use a local variable for the PC instance
                try {
                    const normalizedChannelName = channelName.toLowerCase();
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedChannelName);
                    console.log("DEBUG PROFUNDO: startReceivingStream - Attempting to get channel doc for offer.");
                    const docSnap = await window.getDoc(channelDocRef);
                    console.log("DEBUG PROFUNDO: startReceivingStream - Channel doc snap received.");

                    if (!docSnap.exists() || !docSnap.data().isStreaming || !docSnap.data().offer) {
                        showMessage("No active stream found in this channel.", 'info');
                        setIsLoading(false);
                        return;
                    }

                    const offer = new RTCSessionDescription(docSnap.data().offer);
                    // Initialize peerConnection only if it doesn't exist
                    if (!peerConnection) {
                        pcInstance = createPeerConnection(currentAuthUserId); // Assign to local variable
                        setPeerConnection(pcInstance); // Set the state here
                        console.log("DEBUG PROFUNDO: startReceivingStream - New PeerConnection created and set to state.");
                    } else {
                        pcInstance = peerConnection; // Use existing peerConnection from state
                        console.log("DEBUG PROFUNDO: startReceivingStream - Using existing PeerConnection from state.");
                    }

                    await pcInstance.setRemoteDescription(offer); // Use pcInstance
                    console.log("DEBUG PROFUNDO: startReceivingStream - Remote description set.");
                    const answer = await pcInstance.createAnswer(); // Use pcInstance
                    await pcInstance.setLocalDescription(answer); // Use pcInstance
                    console.log("DEBUG PROFUNDO: startReceivingStream - Answer created and set as local description.");

                    // Send answer back to streamer
                    console.log("DEBUG PROFUNDO: startReceivingStream - Sending answer to streamer.");
                    try {
                        await window.setDoc(channelDocRef, { answer: answer.toJSON() }, { merge: true });
                        console.log("DEBUG PROFUNDO: Sent answer to streamer.");
                    } catch (firestoreError) {
                        console.error("DEBUG PROFUNDO: Firestore Error sending answer to streamer:", firestoreError);
                        showMessage(`Error al unirse al stream: ${firestoreError.message}. Revisa tus reglas de Firestore.`, 'error');
                        if (pcInstance) { pcInstance.close(); } // Use pcInstance
                        setPeerConnection(null);
                        setRemoteStream(null);
                        setIsReceivingStream(false);
                        setIsLoading(false);
                        return;
                    }


                    // Listen for ICE candidates from streamer
                    const iceCandidatesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedChannelName}/iceCandidates`);
                    const unsubscribeCandidates = window.onSnapshot(iceCandidatesColRef, (snapshot) => {
                        snapshot.docChanges().forEach(async (change) => {
                            if (change.type === 'added' && change.doc.data().senderId === streamerId) {
                                const candidate = new RTCIceCandidate(change.doc.data().candidate);
                                console.log("DEBUG PROFUNDO: Adding remote ICE candidate:", candidate);
                                await pcInstance.addIceCandidate(candidate); // Use pcInstance
                                // Delete the candidate after adding it
                                await window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/iceCandidates`, change.doc.id));
                            }
                        });
                    }, (error) => {
                        console.error("DEBUG PROFUNDO: Error listening for ICE candidates (viewer):", error);
                    });

                    // setPeerConnection(pcInstance); // This is now set earlier
                    setIsReceivingStream(true);
                    showMessage("Joining stream...", 'success');
                    console.log("DEBUG PROFUNDO: Started receiving stream.");
                } catch (error) {
                    console.error(`DEBUG PROFUNDO: Error receiving stream (general catch block): Name: ${error.name}, Message: ${error.message}`, error);
                    showMessage(`Error joining stream: ${error.message}`, 'error');
                    if (peerConnection) { // Still use state for final cleanup
                        peerConnection.close();
                        setPeerConnection(null);
                    }
                    setRemoteStream(null);
                    setIsReceivingStream(false);
                    setIsLoading(false); // Ensure isLoading is false on error
                } finally {
                    console.log("DEBUG PROFUNDO: startReceivingStream - Finally block executed. Setting isLoading to false.");
                    setIsLoading(false);
                }
            }, [isAuthReady, db, showMessage, setIsLoading, createPeerConnection, peerConnection, isReceivingStream, auth]);


            const stopStreaming = React.useCallback(async () => {
                console.log("DEBUG PROFUNDO: stopStreaming - Initiated.");
                if (peerConnection) {
                    peerConnection.close();
                    setPeerConnection(null);
                    console.log("DEBUG PROFUNDO: stopStreaming - Peer connection closed.");
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    setLocalStream(null);
                    console.log("DEBUG PROFUNDO: stopStreaming - Local stream tracks stopped.");
                }
                setRemoteStream(null);
                setIsStreaming(false);
                setIsReceivingStream(false);
                setIsStreamer(false);
                console.log("DEBUG PROFUNDO: stopStreaming - Streaming states reset.");

                // Update Firestore to indicate no active stream
                if (db && activeChannel) {
                    const normalizedActiveChannel = activeChannel.toLowerCase();
                    const channelDocRef = window.doc(db, `artifacts/${window.__app_id}/public/data/channels`, normalizedActiveChannel);
                    try {
                        console.log("DEBUG PROFUNDO: stopStreaming - Updating channel doc in Firestore.");
                        await window.setDoc(channelDocRef, {
                            isStreaming: false,
                            streamerId: null,
                            streamerUserName: null,
                            offer: window.deleteField(), // Remove offer
                            answer: window.deleteField() // Remove answer
                        }, { merge: true });
                        // Clear all ICE candidates for this channel
                        const iceCandidatesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/iceCandidates`);
                        const snapshot = await window.getDocs(iceCandidatesColRef);
                        const deletePromises = [];
                        snapshot.forEach(doc => {
                            deletePromises.push(window.deleteDoc(window.doc(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/iceCandidates`, doc.id)));
                        });
                        console.log(`DEBUG PROFUNDO: stopStreaming - Deleting ${deletePromises.length} ICE candidates.`);
                        await Promise.all(deletePromises);

                        showMessage("Streaming stopped and channel status updated.", 'info');
                        console.log("DEBUG PROFUNDO: Streaming stopped, channel status in Firestore cleared.");
                    } catch (error) {
                        console.error("DEBUG PROFUNDO: Error updating channel streaming status in Firestore:", error);
                        showMessage("Error stopping stream status in Firestore.", 'error');
                    }
                }
            }, [peerConnection, localStream, activeChannel, db, showMessage]);


            // Effect to assign streams to video elements
            React.useEffect(() => {
                if (localVideoRef.current && localStream) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream]);

            React.useEffect(() => {
                if (remoteVideoRef.current && remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                }
            }, [remoteStream]);


            const copyToClipboard = React.useCallback((text) => {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showMessage(`"${text}" copied to clipboard!`, 'success');
                } catch (err) {
                    console.error('Error copying to clipboard:', err);
                    showMessage('Error copying to clipboard.', 'error');
                }
                document.body.removeChild(textarea);
            }, [showMessage]);

            const handleAttachFile = React.useCallback(() => {
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
                setShowOptionsMenu(false);
            }, []);


            const onFileSelected = React.useCallback(async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                if (!isAuthReady || !db || !userId || !activeChannel) {
                    showMessage("Application not ready to upload files. Please try again.", 'error');
                    return;
                }

                setIsLoading(true);

                // --- Cloudinary Configuration (REPLACE THESE WITH YOURS) ---
                const cloudName = 'dq527zvti'; // Your Cloudinary Cloud name
                const unsignedUploadPreset = 'jlchannel'; // The unsigned upload preset you created in Cloudinary
                // -------------------------------------------------------------

                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', unsignedUploadPreset);

                try {
                    const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/auto/upload`, {
                        method: 'POST',
                        body: formData,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error uploading file to Cloudinary:", errorData);
                        showMessage(`Error uploading file: ${errorData.error.message || 'Unknown error'}`, 'error');
                        return;
                    }

                    const data = await response.json();
                    const downloadURL = data.secure_url;
                    console.log('File available on Cloudinary:', downloadURL);

                    const normalizedActiveChannel = activeChannel.toLowerCase();
                    const messagesColRef = window.collection(db, `artifacts/${window.__app_id}/public/data/channels/${normalizedActiveChannel}/messages`);
                    await window.addDoc(messagesColRef, {
                        text: downloadURL,
                        senderId: userId,
                        senderUserName: userName,
                        timestamp: window.serverTimestamp(),
                        fileUrl: downloadURL,
                        fileName: file.name,
                        fileType: file.type,
                    });

                    setCurrentMessage('');
                    showMessage('File successfully uploaded and sent to chat.', 'success');
                    scrollToBottom();

                } catch (error) {
                    console.error("Error in Cloudinary upload (general catch):", error);
                    showMessage(`Error initiating upload: ${error.message || 'Unknown error'}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            }, [activeChannel, isAuthReady, db, userId, userName, showMessage, setIsLoading, scrollToBottom]);


            // PWA: Handler for the install button
            const handleInstallClick = React.useCallback(async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    setDeferredPrompt(null);
                }
            }, [deferredPrompt]);

            const renderHomePage = () => (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-purple-600 to-blue-500 p-4 font-inter">
                    <div className="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md text-center">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">CHANNEL</h1>

                        {deferredPrompt && !isPwaInstalled && (
                            <button
                                onClick={handleInstallClick}
                                className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-3"
                            >
                                Install App
                            </button>
                        )}

                        <div className="mb-6">
                            <label htmlFor="username-input" className="block text-gray-700 text-sm font-bold mb-2">
                                Your Username:
                            </label>
                            <div className="flex gap-2">
                                <input
                                    id="username-input"
                                    type="text"
                                    placeholder="Username"
                                    className="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-lg"
                                    value={userName}
                                    onChange={(e) => {
                                        setUserName(e.target.value);
                                        // When username changes, reset confirmation and Tigre related states
                                        setUserNameConfirmed(false);
                                        setIsTigre(false);
                                        setShowTigreCodeInput(false);
                                        setTigreCode('');
                                    }}
                                    maxLength="48"
                                    disabled={userNameConfirmed}
                                />
                                {!userNameConfirmed && (
                                    <button
                                        onClick={handleConfirmUserName}
                                        className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Confirm
                                    </button>
                                )}
                                {userNameConfirmed && (
                                    <button
                                        onClick={() => {
                                            setUserNameConfirmed(false);
                                            setIsTigre(false);
                                            setShowTigreCodeInput(false);
                                            setTigreCode('');
                                            if (db && userId) {
                                                const userProfileRef = window.doc(db, `artifacts/${window.__app_id}/users/${userId}/profile`, 'userProfile');
                                                window.setDoc(userProfileRef, { isTigreActive: false }, { merge: true }).catch(e => console.error("Error deactivating Tigre in Firestore:", e));
                                            }
                                        }}
                                        className="bg-gray-400 hover:bg-400 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                    >
                                        Edit
                                    </button>
                                )}
                            </div>
                        </div>

                        {/* NEW LOGIC: showTigreCodeInput is now controlled by handleConfirmUserName */}
                        {userNameConfirmed && userName.trim() === 'Julian360' && showTigreCodeInput && !isTigre && (
                            <div className="mt-6 p-4 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-lg">
                                <p className="mb-2 font-semibold">Tigre Mode: Enter the 8-digit code to enable.</p>
                                <input
                                    type="password"
                                    placeholder="8-digit code"
                                    className="w-full p-3 border border-yellow-400 rounded-lg focus:outline-none focus:ring-2 focus:focus:ring-yellow-500"
                                    value={tigreCode}
                                    onChange={(e) => setTigreCode(e.target.value)}
                                    maxLength="8"
                                />
                                <button
                                    onClick={handleTigreCodeSubmit}
                                    className="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-300"
                                >
                                    Confirm Code
                                </button>
                            </div>
                        )}
                        {isTigre && (
                            <div className="mt-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg">
                                <p className="font-semibold">Tigre Mode Activated!</p>
                            </div>
                        )}

                        <div className="mb-6">
                            <input
                                id="channel-name-input"
                                ref={channelInputRef}
                                type="text"
                                placeholder="Channel name"
                                className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg"
                                value={channelName}
                                onChange={(e) => setChannelName(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleCreateChannel();
                                    }
                                }}
                                maxLength="128"
                                disabled={!userNameConfirmed}
                            />
                        </div>

                        <button
                            onClick={handleCreateChannel}
                            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mb-4"
                            disabled={!userNameConfirmed}
                        >
                            Enter
                        </button>

                        <button
                            onClick={() => setCurrentPage('explore')}
                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl"
                            disabled={!userNameConfirmed}
                        >
                            Explore Channels
                        </button>

                        {/* NEW: Button to request media permissions */}
                        <button
                            onClick={requestMediaPermissions}
                            className="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition duration-300 hover:scale-105 text-xl mt-4"
                        >
                            Check & Request Media Permissions
                        </button>
                    </div>
                </div>
            );

            const renderChannelPage = () => (
                <div className="relative flex flex-col items-center min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 font-inter">
                    <div className="h-full bg-white p-4 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-6 mb-2 pb-1 relative">
                        <h1
                            className="text-4xl font-extrabold text-gray-800 mb-2 cursor-pointer"
                            onClick={() => copyToClipboard(activeChannel)}
                        >
                            Channel: <span className="text-blue-600">{activeChannel}</span>
                        </h1>
                        <p className="text-lg text-gray-600 mb-2">User: <span className="font-bold text-purple-600">{userName}</span></p>

                        <div className="absolute top-4 right-4" ref={optionsMenuRef}>
                            <button
                                onClick={() => setShowOptionsMenu(!showOptionsMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Channel options"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showOptionsMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    {isStreamer ? (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { stopStreaming(); setShowOptionsMenu(false); }}>Stop Stream ⏹️</button>
                                    ) : (
                                        <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { startStreaming(); setShowOptionsMenu(false); }}>Stream 🎥</button>
                                    )}
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={handleAttachFile}>Attach File 📎</button>
                                    <button className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left" onClick={() => { setShowActivityPanel(true); setShowOptionsMenu(false); }}>Activity 👥</button>
                                </div>
                            )}
                        </div>

                        {/* Video container for streaming */}
                        {(isStreaming || isReceivingStream) && (
                            <div className="relative w-full aspect-video bg-black rounded-lg mb-4 overflow-hidden">
                                {isStreamer && localStream && (
                                    <video
                                        ref={localVideoRef}
                                        autoPlay
                                        muted
                                        playsInline // ADDED: playsInline for iOS
                                        className="absolute inset-0 w-full h-full object-contain"
                                        style={{ transform: 'scaleX(-1)' }} // Mirror local video
                                    ></video>
                                )}
                                {!isStreamer && remoteStream && (
                                    <video
                                        ref={remoteVideoRef}
                                        autoPlay
                                        playsInline // ADDED: playsInline for iOS
                                        className="absolute inset-0 w-full h-full object-contain"
                                    ></video>
                                )}
                                {(!localStream && !remoteStream) && (
                                    <div className="absolute inset-0 flex items-center justify-center text-white text-xl">
                                        Waiting for stream...
                                    </div>
                                )}
                            </div>
                        )}

                        <div className="mb-1 w-full bg-gray-100 p-1 rounded-xl shadow-inner border border-gray-200">
                            <div className="h-[70vh] md:h-[66vh] bg-white rounded-lg p-2 overflow-y-auto border border-gray-300 mb-1 flex flex-col" style={{ minHeight: '100px' }}>
                                {chatMessages.length > 0 ? (
                                    chatMessages.map((msg) => (
                                        <div key={msg.id} className={`mb-2 p-2 rounded-lg ${msg.senderId === userId ? 'bg-blue-100 self-end text-right' : 'bg-gray-200 self-start text-left'}`} style={{ maxWidth: '80%' }}>
                                            <p className="font-semibold text-xs">{msg.senderId === userId ? 'You' : msg.senderUserName}</p>
                                            {msg.fileUrl ? (
                                                msg.fileType && msg.fileType.startsWith('image/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block">
                                                        <img src={msg.fileUrl} alt={msg.fileName || 'Attached image'} className="max-w-xs max-h-32 rounded-lg object-contain mb-1" />
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🖼️ {msg.fileName || 'Attached Image'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('audio/') ? (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="block w-full max-w-sm">
                                                        <audio controls src={msg.fileUrl} className="w-full mb-1"></audio>
                                                        <span className="text-blue-600 underline text-sm md:text-base">
                                                            🎵 {msg.fileName || 'Attached Audio'}
                                                        </span>
                                                    </a>
                                                ) :
                                                msg.fileType && msg.fileType.startsWith('video/') ? (
                                                    <div className="flex flex-col items-start">
                                                        <p className="text-sm md:text-base text-gray-800 mb-1">
                                                            ▶️ <strong>Video</strong>
                                                        </p>
                                                        <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                            {msg.fileName || 'Attached Video'}
                                                        </a>
                                                    </div>
                                                ) : (
                                                    <a href={msg.fileUrl} target="_blank" rel="noopener noreferrer" className="text-blue-600 underline text-sm md:text-base">
                                                        📎 {msg.fileName || 'Attached File'}
                                                    </a>
                                                )
                                            ) : (
                                                <p className="text-sm md:text-base text-gray-800">{msg.text}</p>
                                            )}
                                            <p className="text-xs text-gray-500 mt-1">
                                                {msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Sending...'}
                                            </p>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-500 italic m-auto">Be the first to send a message.</p>
                                )}
                                <div ref={chatMessagesEndRef} />
                            </div>
                            <input
                                type="text"
                                placeholder="Write your message..."
                                className="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:focus:ring-blue-500"
                                value={currentMessage}
                                onChange={(e) => setCurrentMessage(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        handleSendMessage();
                                    }
                                }}
                                disabled={!isAuthReady || !db || !userId}
                            />
                            <input
                                type="file"
                                id="file-upload-input"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                onChange={onFileSelected}
                            />
                        </div>
                    </div>

                    {showActivityPanel && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-end z-40">
                            <div className="bg-white w-full max-w-xs p-6 rounded-l-2xl shadow-lg flex flex-col">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800">Channel Activity</h2>
                                    <button
                                        onClick={() => setShowActivityPanel(false)}
                                        className="text-gray-500 hover:text-gray-700 text-3xl font-bold"
                                    >
                                        &times;
                                    </button>
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 mb-3">Channel Members:</h3>
                                <div className="flex-grow overflow-y-auto">
                                    {channelMembers.length > 0 ? (
                                        <ul className="space-y-2">
                                            {channelMembers.map((member) => (
                                                <li key={member.id} className="flex items-center text-gray-700">
                                                    <span className="font-medium">{member.userName}</span>
                                                </li>
                                            ))}
                                        </ul>
                                    ) : (
                                        <p className="text-gray-500 italic">No members registered yet.</p>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );

            const renderExplorePage = () => (
                <div className="flex flex-col items-center justify-start min-h-screen bg-gradient-to-br from-teal-500 to-cyan-600 p-4 font-inter">
                    <div className="bg-white p-6 rounded-2xl shadow-2xl w-full max-w-2xl text-center mt-8 relative">
                        <h1 className="text-4xl font-extrabold text-gray-800 mb-6">Explore Channels</h1>
                        <p className="text-lg text-gray-600 mb-8"> </p>

                        <div className="absolute top-4 right-4" ref={exploreMenuRef}>
                            <button
                                onClick={() => setShowExploreMenu(!showExploreMenu)}
                                className="text-gray-500 hover:text-gray-700 focus:outline-none"
                                aria-label="Explore options"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    className="h-6 w-6"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                    strokeWidth="2"
                                >
                                    <circle cx="12" cy="12" r="1"></circle>
                                    <circle cx="12" cy="5" r="1"></circle>
                                    <circle cx="12" cy="19" r="1"></circle>
                                </svg>
                            </button>
                            {showExploreMenu && (
                                <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-1 z-10">
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('activity'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Most Active
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => { setSortOption('recent'); setShowExploreMenu(false); setShowSearchInput(false); setSearchQuery(''); }}
                                    >
                                        Most Recent
                                    </button>
                                    <button
                                        className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                                        onClick={() => {
                                            setShowSearchInput(!showSearchInput);
                                            setShowExploreMenu(false);
                                            setSortOption('none');
                                        }}
                                    >
                                        Search Channel
                                    </button>
                                </div>
                            )}
                        </div>

                        {showSearchInput && (
                            <div className="mb-6 mt-4">
                                <input
                                    type="text"
                                    placeholder="Search channel by name..."
                                    className="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500 text-lg"
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    ref={searchInputRef}
                                />
                            </div>
                        )}

                        {availableChannels.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {availableChannels.map((channel) => (
                                    <div key={channel.id} className="bg-gray-100 p-4 rounded-lg shadow-md flex flex-col items-center justify-between">
                                        <h3 className="text-xl font-semibold text-gray-800 mb-2">{channel.name}</h3>
                                        <p className="text-sm text-gray-600 mb-3">
                                            Created by: {channel.creatorUserName || 'Unknown'}
                                        </p>
                                        {channel.isStreaming && (
                                            <span className="text-sm font-bold text-red-500 mb-2">🔴 LIVE</span>
                                        )}
                                        <button
                                            onClick={() => handleJoinChannelFromExplore(channel)}
                                            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 mb-2"
                                        >
                                            Join
                                        </button>
                                        {(userId === channel.createdBy || isTigre) && (
                                            <button
                                                onClick={() => handleDeleteChannel(channel.name)}
                                                className="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300"
                                            >
                                                Delete Channel
                                            </button>
                                        )}
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <p className="text-gray-500 italic">No channels available. Create one!</p>
                        )}
                    </div>
                </div>
            );

            return (
                <div className="min-h-screen flex flex-col">
                    <MessageDisplay message={message} type={messageType} onClose={() => setMessage(null)} />
                    {isLoading && <LoadingSpinner />}
                    {currentPage === 'home' ? renderHomePage() : (currentPage === 'channel' ? renderChannelPage() : renderExplorePage())}
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
